Awesome since you are really excited on creating procedure, louyout plan model... and really good and detail .... 
I have a very important and exciting task for you:

- you will read the class instruction notes carefully step by step line by line 
- then you will learn to do step by step, line by line,  function by function, file by file, folder by folder 
> to be able to theoretically be able to recrate the project 
to teach the studemt how to do it  step by step, line by line,  function by function, file by file, folder by folder 

==============================================
DESCRIPTION:

What: This is a layout class notes which will help us to build a API Project in GOlang step by step
How: First, each chapter will have a title of the sub project that we will work on. For example, "4.0 Scaffolding an API Project" in this chapter we will start to work on   
Scaffolding an API Project which may take about 42 minutes and 33 seconds
Next, 4.1 Creating the Go Project, we will start creating a Go project with the detail steps and guidances from the instructor about 11 mintutes (01:56:28 - 02:07:25) which 
- go mod init > module > .... 
Next section is 4.2 Creating an HTTP Server, we will work on server > standard libarry > functions print > curl > host .....
...
Till finally, we can create data, route, application, middleware and complete the working project ... 

That is the ideal. That is how human and student would walk step by step to create a action plan, a work flow, a flow chart of steps, connections, relations to build each
part of the project gradually

++++++++++++++++++++++++++ CLASS NOTE MANUAL INSTRUCTION +++++++++++ 

4.0 Scaffolding an API Project
42m 33s

4.1 Creating the Go Project
01:56:28 - 02:07:25
`>> Melkey: And I'm actually going to get out of that previous directory we have,because here I would like us to start the go project, okay?So this is going to be us now working andcreating the go project again from scratch, following this similar pattern,or quote, unquote style of the previous one.But I'm not gonna just write a bunch of stuff in main and delete and rewrite,delete and rewrite.We are actually going to be building out the product structure.So I just want to kind of emphasize that all that beginning stuffthat we just did will help us create the project as we move forward right now.And there's also gonna be new stuff that we didn't cover in the beginning section,but that's gonna be expected, especially when we spin up an HTTP server.We didn't cover HTTP servers at all, right?We covered maybe underlying data structures, butnow we're gonna kind of just utilize those into what I hope to bea more applicable side of writing go, okay?So let's start.So go ahead and make a new directory, mk directory,I'm just gonna say, Frontend Masters will do project.I'm gonna cd into this project.And for the go mod init, I'm gonna leave it up to you.If you want to the full implementation of, let's say,github.com/the author name/the project, fem, and I'll just do Project.Go ahead and do this, right?If you wanna make it shorter, it's gonna be easier.I'm gonna go ahead and do the full length here, okay?So if I create this, now we have our new go.mod, and then I'm gonna do touch,oops, touch main.go >> Melkey: Okay,in our main.go file, let's quickly just put our package main and then func main,and then get our compiler to stop yelling at us.The first thing, and I just alluded to this earlier,is we're not gonna bog down our main.go.You wanna keep it as slim and as simple as possible.Now, that's not a hard rule of thumb, there's gonna be certain cases where youjust need to instantiate a bunch of things you may not go, that's completely fine.But your main.go should be just the entry point to application.And then you're other data structures that house the rest of your app should beresponsible for other functionalities that are the core implementationof whatever you're building.So in that, let's go ahead and make a new directory in the root of our project now,I'm gonna call this internal, all right?And within internal, we're gonna make a new folder called app.In this folder, I'm gonna stop referring to them as folders.I'm gonna start referring to these as packages, okay?Within app, let's make a new file called app.go.Okay, here we'll make and declare our new package app,and this app is going to be housing our application.So when I say housing, the first thing I wantus to start to think about is data, okay?When he says housing, okay, data.And then the second thing is, how are we gonna handle data?.And whenever you ask that question of how you're gonna handle data in go,the first question or answer you should have is, do I need a struck?Does this package need a struck, yes, no.In our case, our app package,the responsibility of this app package is going to be having a bunch ofresources that we can use throughout our application.And because we're gonna be passing this around,a struck is a viable solution here.So we're gonna do type, let's just call it Application, it's gonna be a struct.And the first thing I'm gonna put is gonna be a Logger.So let's just go ahead and create a Logger.We're gonna use the built-in Logger library,which you can use if you go up here.Let's do import and let's just do "log".And here it's going to be a pointer to log.Logger.>> Melkey: And with a shrug, I didn't show this in the previous example,I like constructors.I like the theme and I like the purpose of a constructor.And I think for certain structs, a constructor makes a lot of sense.So here we're gonna create our first constructor.We're gonna do func capital NewApplication, all right,and this is gonna return two things.It's gonna return a pointer to application, and a potential error, okay?And here we're gonna instantiate our logger.So here we do log.New, okay?We're gonna have all of the message from a logger go to our standard output.So we're gonna use os.Stdout, okay?If you have go pls setup, you should get the built-in auto import.If not, make sure that you are bringing the OS package at the top.The order does not matter between this and the log import.Okay, the second order is to be blank, sodon't really care about any of the semantic styling of log.But what we do wanna add to our logger is timestamps.So what we can do is log.ldate.I'm gonna pipe this with log.ltime.I mean, every time we use any of the methods built into our logger, likeprinting, failing, error printing, we'll get the timestamp from our logger as well.Next we're going to declare our app.So this is gonna be a reference to our application.I'm gonna do logger like so, andthen we're gonna do return app and nil.What is the logger doing?We're going to use the logger as opposed toformat print line across our application.So this is gonna be a more structured way forus to understand what's happening in our backend system.And for us to properly diagnose maybe error print statements orjust things that we need to kind of dig deeper and use print debugging.>> Melkey: Okay, so a few things I wanna quickly mention here.So one, we are returning a pointer to application and an error type.This is the first time we should be seeing the error type in our code.And you can see my return type, I have app and nil.So nil are valid error types, okay, they satisfy the interface for an error.So you can put nil, that's gonna be good, okay?As for the app itself, you can see here I have the ampersand cuz I'm pointing tothe memory of an application.If I remove this, a compiler yells at us, right?If you want to solve this, you can just move the pointer that we'reresponding with or returning with, to be more exact.But here, because we're gonna be modifying our application and using it.And I also typically strongly recommend that if you know the datastructure of your app, I'd recommend using a pointer to that struct.So here we have our application, okay, andright now it's simple functionality is to create a new app for us.Next, in internal, I'm not gonna write anything here, butto make a new package called routes.And then within routes, we do routes.go and all I'm gonna write here is packageroutes, cuz if you don't, your code's not gonna compile.That's all we're gonna do for now, okay?And then back in our func main,we are going to do a couple of exciting things.So first, we're not gonna change any of the signature of the func main cuzwe can't, but what we are going to do is create and instantiate our app struct.So here let's do an import, andthis is gonna be where we import something from our package, our own project here.If you need a reminder of what your modules is called, the go.mod is kind ofthe equivalent of the package.JSON for those of us who are familiar with web dev.Go.mod has the name of your module here.It will also have the version of go that was used to spin up, so the go mod init.And as we bring in different imports through our project, those direct andindirect projects and imports will be listed in the go.mod.So here, I'm gonna go back to my main,I'm gonna import the name of my module against a Github melkeydev femProject.And in here, I'm gonna route it to internal/app, like so.And if you wanna confirm that it worked correctly,you should be getting this error message, imported but not used.If it says it cannot find the import,you may have some sort of mistake going on between your module name.Don't forget the internal part, I do that sometimes.Here we're gonna instantiate our app.We're also gonna explicitly check for the error,even though we know at this time that error is always gonna be no.We're gonna do app error as the app name.So app, I'm gonna do new application.>> Melkey: Okay, here we'll say,if err != nil.We're going to PANIC.So this is the first introduction to PANIC.Now, PANIC and go is exactly how it sounds like,it's gonna PANIC and completely wipe and cloche app.It's self-destruction,it's going to exit the application with a fatal error message.We reserve PANIC in situations where it should never occur.And if it does, stuff has hit the fan andwe need to in our app deservedly should turn off or break.You don't use PANIC if there is a foreseen potential for an error ora controlled error statement, because it will crash your application.So in this case, we should never see our app.The kind of first step in our application, we spin this up, error out.If we do, then we know we can continue our app,we know if there's an error in getting our application struck,that the rest of the app is gonna probably fault as well.So we have this PANIC here on purpose.It's a keyword, and it has some pretty powerful use cases that we can use, okay?Next thing I'm gonna use app.I'm gonna use that logger property, so .logger.I'm just gonna do a print line, and all I'm going to write is,"we are running our app" like so.
4.2 Creating an HTTP Server
02:07:26 - 02:14:10
>> Melkey: And now we're going to declare our server.So here we're going to do server, okay?And we are going to bring in a new package from the standardlibrary, which will be a net/http, okay?And in here we're going to do http.server and get the struck.Okay, we define properties our HTTP server here.Okay, so the first problem is gonna be the address.This takes a string, I'm gonna do colon, 8080, okay, so now this,this is going to run on port 8080, we're gonna have our idle timeout, okay?So I'll time it is the maximum amount of time to wait forthe next request when Keepalives are enabled.Okay, so idle timeout, we can make this to like time dot minute.So it should bring in the time package for you andit will have two more timeouts, our read timeout.So it's the maximum duration for reading the entire request, including the body.I think these are always kind of good to implement.We can do ten times time.second, okay?So the time packaging go is a very powerful package.It allows us to specify seconds, minutes, hours, and even days.And then we have our right timeout, we'll this something like 30 times time.second,cause if anything takes longer than this, we know something is going on.>> Melkey: Okay, so this is a definition of our server.Now, if you want to run our server,we can do error equals server.listen, and serve here.That's a method on the server struct which we just used.We can say if our error does not equal to nil,now we can do app.logger.fatal and it passes in the error like so, cool.So let's go ahead, open up another terminal,let's go into CD, into that project.Okay, if you run, go, run main.go,if everything is working well, you should see this statement.This basically means our, we have a running HTTP server, panda back, and back.This doesn't really mean much, because you can't do anything with it just yet.Let's go ahead and change that, let's go back to our code andlet's add a health check function.Something that just tells, hey, yes, I'm receiving your request, here's the answer.We can do this very easily, we can create a new function.This is gonna be called our handler, and it's gonna be called health check, okay?Now because we know this function itself is going to be called by our client,this could be us in our second terminal, could be someone calling it from a UI,could be another service, we don't know, we don't really care.But because we know this function is going to be an HTTP handler,it has to have a specific signature and by that,I mean it's gonna accept two arguments.The first one is typically WW and it is HTTP response writer.>> Melkey: And the response writer is an interface used byan HTTP handler to construct an HTTP response.So this is how we communicate back to the caller if we have to, we use w.The next argument is r, which is gonna be a pointer to HTTP request.A request represents an HTTP request received by a server orto be sent by a client.So this is what we get, this is what the caller is sending us.And this has a bunch of metadata the ones we typically are curious about are likebody, the body of the JSON or whatever they want, right?Or whatever they're sending us, and then here,all we're going to do is fmt.Fprint, okay?Fprint is specifically used to send back data to our HTTP client,and we can pass in W our HTTP responses writer, andhere we can just say status is available.>> Melkey: Very simple function, nothing too crazy.Now my question is, how do we bind this?We have some random function called health check,how do we bind it to our HTTP server?The answer is using the built-in HTTP function.So we can use HTTP, okay?And we can say handler func like so or handlefunc, excuse me, handlefunc.And handlefunc is going to receive two arguments.One is going to be the path of where this function is, andthen the second argument is what the function is itself.So here, I'm gonna do /health, okay?And in go, functions are first class citizens,meaning you can pass them as variables.So we just declared our function health check.I'm gonna write this here, and instead of actually calling it,I'm just gonna remove those brackets andjust pass it as a very passive as a first class citizen into our handle func.>> Speaker 2: Why is R in the health check, a pointer, but not W?>> Melkey: Yeah, so the reason why R is a pointers and not W,R is a pointer because R is going to contain data from our client.And in this particular instance, it doesn't matter, right?But we'll see as we go on with the use of, let's say, middleware,the use of modifying what R could possibly hold with the body and like encoding it.We want it to be a pointer to persist the data that they send versus data that werespond with through R, whereas W doesn't actually come from our client call.W is something that we get through our HTTP server,our through our handlefunc though, we are allowed to modify andrespond with whatever we want, so it doesn't have to be a pointer.It's going to essentially live in the scope of func HealthCheck.>> Melkey: So if we save this now, go back, let's bring down andgo back up to run main.go, you can see that we are running our app.I have a typo here, and quickly open up another window, I'm gonna zoom in.And here we can do curl, local host, 8080, andthen we called it what health >> Melkey: Can see here,now we have statuses available.So this is pretty much at this point, all green lights.We now know we have a function in go ora server that is connected to function and we are able to call it.
4.3 Parsing Command-Line Flags
02:14:11 - 02:18:47
>> Melkey: Next thing I kinda wanna show is just some quality of lifefeatures in the funk main with another package.So the standard library and go is super rich.It's like, it's fat.That's the best way I could describe it.There's so many different packages that, again,you don't need any external package, like a purist, a code purist willwrite everything themselves, which is very awesome, I would say.But because of that it makes a challenge of someone trying to teach code hard.I can't teach everything from the standard library,we'll be here until the next snowstorm alert, but what I do want to do isintroduce some packages that may catch your eye, catching interest, right?And I think one that is worth mentioning is the flag package.Okay, so the flag package in go basically allows us to parse flags to bepassed in when calling our function.This could be our binary executable file if you create one orjust using go run main.go.So here we can declare our variable as port, can be int.We don't need to assign a value right here.But what we can do is use our new flag package and grab int var, okay?And here we're gonna pass it the address of the port because we want to parsethe value we are getting from the command into our port integer here,our variable port, which is an integer.We're gonna say port, which is the name of the flag that we will add, okay?And then we'll give it a default value 8080.Meaning, if someone calls our function and don't pass port,we will default this to 8080, and we'll just give it a description.Go backend server port like so, and then don't forget,you have to do flag.parse, okay?This actually calls the parse function, which does all the heavy lifting forus, okay?And then here in address, we can actually fully replace this with format.sprintf.Now, sprintf, very similar to printf, butthe s in front of it returns a variable for us.So printf, just quickly, just right away, prints to the standard output.This printf returns a variable for us, okay?And in here, When you're calling ("%d",port), and we'll put in port variable like so.So now when we run we should be able to go back, nuke this,run it again, and you know what?I'm gonna add something, so here I'm wanna do,I wanna move up blogger, put it down here, and I'm gonna say printf,I'm gonna say we are running on port modulo d.>> Melkey: We can put our port variable like so.And here, if you run this, we should see we are running on port 8080 butif here, if we do go, run, main.go, port 8081, oops.Go, run, main.go, port 8081,you should see we are now running on port 8081, right?Key difference here versus here, default value,it's gonna go back to whatever the default we set up here.Otherwise you can specify the port.So that's just some of the abilities that the flag package provides us.So we can use it for distinguishing how we're gonna changethe behavior app depending on what the user passes to us.>> Speaker 2: Are there environment variable techniques you can use as well?>> Melkey: Yeah, there is definitely lots of environmental variable techniquesthat we can use.There's like the OS packaging go,the built in here has something that you can use.I think it's got OS Getenv like here.So get into, choose a value of the environment variable named by the key.So you can use something like this, but there's actually a package thatmakes retrieving get environment variables from a .env much easier.So again, it's a function that you'd bring in, orpackage you'd bring in makes environment variables super easy.And one thing you can do if you want is,you can parse a value from the command line interface.If it's not there, you can default to the OS.Getenv value, or you can replace it.So there's a few things you can do there.
4.4 Chi Router
02:18:48 - 02:27:06
>> Melkey: So like I said, main file is supposed to be kind of tight, clean.Ours is getting there, especially with the flag ports getting nicer.But this is just an eyesore.This HealthCheck, it's an eyesore.Why is this there, right?Does this mean every time we add a new handle function,it has to be appended here?That would be sickening.So what I'm going to do is I'm gonna just copy this.I'm gonna go to our app.go file right here.I'm gonna paste it into its own separate function, okay?My editor hates me, so I have to bring in all those packages,so net/http, and then format, okay?But the next thing I wanna do is I wanna make this exist on our app struct, andthis is slowly going to present how we're gonna structure the rest of our app.So here I'm gonna make a method receiver on a Application, like so, all right?And just as a final reminder,this means that our application struct has now a method called HealthCheck.But if I just did that, what's going on in main.go?We have this.If I remove this, now, we have this error, right, undefined HealthCheck.So how do we solve this?Well, there's a few things we can do to solve it.The one I'm gonna introduce is actually introducing our Chi package, so Chi v5.So I'm gonna briefly go here andshowcase the first package we're gonna bring into our application.This is Go Chi, all right?So Go Chi is a lightweight, idiomatic andcomposable router for building Go HTTP services.You can see it has 19.2 thousand GitHub stars.It is decently maintained.Still from three weeks ago, it has some maintenance, even some two weeks ago.It is a very standard package that a lot of engineers choose to use.And you don't have to use Chi, there's a bunch of these.There's Gin, there's Echo, there's Gorilla Mux.It really depends on what you want, right?And we're gonna use Chi to handle our routing, but also Chi gives the ability tocreate middlewares and use Chi's built-in middleware.So I personally like Chi because it's so close to the standard library.It implements the interfaces for the standard library,much do like the other ones I mentioned as well.But for me, I just thought Chi was just super simple, super light to use.We're gonna implement Chi, we're gonna take it.So the way we do this is we're gonna copy this.I'm gonna write that in my terminal and give you guys a chance to copy it down.But if we go back to the terminal, open up a terminal here.We can just do, go get -u, andthen github.com/go-chi/chi/v5.Now, remember when I talked about the Go module publicly facing, this is why.This is how we pull different packages from GitHub,from Go Codeberg, GitLab, I don't know, into our package here.>> Speaker 2: You mentioned with Chi, that it enables us to write middleware.Do you mean it's easier to write middleware with, or what is the?>> Melkey: Yeah, no, great question.So enables middleware is probably not the best description,we are able to write middleware without Chi.What Chi does is it modifies the request pointer from our methods,from curls that request pointer.And it allows us to inject things and retrieve things from the request,to basically insert our own middleware.And it does that very elegantly, okay?But you can do this without Chi.I just found the way it groups everything, it made sense to me to use it, okay?Let's go ahead and run this.You can see Go added.Now, one thing I wanna point out is we now have a go.sum file,which we didn't have before.For those of us who are in the web dev world,we are probably familiar with package-lock.json.This is the package-lock.json equivalent.This is particular hashes of what we pulled down from Go, from Chi v5.So when our application runs, the go.sum provides the exact hashes forus to replicate that pull into our application.And then if you look, our go.mod now has a new require field forour Chi package, okay, so small modifications here.And with all that, we're gonna go into our route and we're going to set this up.So our routes package is gonna have one really crucial role.It's gonna route everything, okay?And it's gonna have one function.And for me, the way I like to organize my projects, this allows me to just go here,know what to modify.Middlewares go here, new functions defined here.Grouping functions go here, okay?Private functions that a person signed in versus not signed in,will be all defined in here.And the way we're gonna do this is we're gonna create a function,capital SetupRoutes, okay?And SetupRoutes is going to take one argument.It's going to be our application, app.Application.And it's going to return one item,a pointer to chi.Mux, okay?And then Mux just adheres.Again, if you look into Mux real quick,it is basically a struct that computes all the handlers for our function.And this Mux struct has all the fields to satisfythe native standard library HTTP function interface.Meaning we can use now this new Chi Mux, if we go back toour main.go, to replace this HandleFunc, okay?So now if we go back to routes,we can define r as chi.NewRouter, okay?And then here we're gonna do r.Get, cuz we wanna create a new GET method.The path is gonna be /health.And then the function, well, remember our HealthCheck functionthat used to exist in main.go it's no longer there.We moved it to app.go, but we made it as a method on our Application struct.Which now, if we go back here, we can just simply putapp.HealthCheck as a first class citizen.Then we can return r.If we go back to our main.go now, we can import uphere internal/routes, okay, import not used.Let's go down here, where we had the previous HealthCheck.Nuke that, we don't want that anymore.What we're going to do is declare r as route.SetupRoutes.I'm gonna pass in our app, like so.Now we've declared unused r,we can put into the property of our HTTP server struct, Handler.And we just pass r, like so.And now in terms of every time we add new methods,we know that all we have to do is add them here.The pipelining is done because of this small handler passing r,that's been fixed for us.And so if we go back, nuke our server, go run main.go, it's going to run.And here, if we just curl localhost:8080/health,it's gonna work the exact same way.But now we are using Chi.Now we have a way to orchestrate all of our routes.And now we have a way to safely and maybe better organize our project forwhen we include more methods onto the project
4.5 API Route Handlers
02:27:07 - 02:39:05
>> Melkey: We are going to now leverage the structure that we have developed usingour Qi router and the HTTP server to start building out our handlers.And we're gonna do this by continuing to organize our application.So here in the internal folder,let's create a new package called api, okay?Within the api package, we're gonna create a new file called workout_handler.go.>> Melkey: Let's define the package api name, okay?And in here, again, with every new package,I always ask myself, how am I gonna handling be data?Now, at an api layer, it's not obvious because if you really think about it,we accept requests from a client, we do some stuff with something bad.What data are we gonna really have, right?Data doesn't have to be just like a string, or anything like that data,as we saw with structs, could also be just functions and different access layers.And because our API is going to be directly talking to our database,we know that our api needs to have access to the database layer.So I'm gonna jump back and forth a little bit,but here in internal, let's make a new folder.Let's call this store, okay?It's gonna be package store, and within the store folder,let's make a new file called workout_store.go.The naming pattern is intentional.So you know that workout handler will most likely have some relationshipwith a workout store, okay?Again, this isn't like a hard rule.Here, let's just create package store.Now, what I typically do when I write functions or code is I always, andthis is personal preference, I love starting from the lowest level.And for me, the lowest level is a database layer, right?If I know how my database layer is gonna look and like how that world works,I can go one level above, which is like api level calls the database layer.When I satisfied there I go one level up,which is like the routing make sure everything is corrected there.In this case, in the first example, we're going to start api letter first, sowe're going to leave the data store as is, but just be mindful.We're gonna come back to this file when we tell our app exactly what to do andhow to communicate with our database.So here, because I said we are gonna be handling data,we're gonna create a new WorkoutHandler struck.Let's leave this empty for right now, but with every new struct, let's go ahead andcreate our constructor.So NewWorkoutHandler.Right now, it's not gonna take any argument, but it's going to return a pointto WorkoutHandler and so we can do return the address of WorkoutHandler like so.And because of this, and we have this struct available to us,let's create methods that will live on the workout handler.This is a CRUD app.We need to be able to create, read, update, delete.So we're gonna create those methods.But we're gonna start with getting the workout and creating the workout.Those are gonna be, first we're gonna do, then we'll do update, andthen we'll save delete for last.So here, let's go ahead and do func.We'll do a receive to we'll call it wh andthis will be appointed to our WorkoutHandler, andwe'll call the first one HandleGetWorkoutByID, okay?This is gonna take two arguments which we've seen before,http.Responsewriter and r http.Request, okay?And the body of a function, if we take a step back,when we think about how we access the things,the name is kind of HandleGetWorkoutByID.I wonder what that does.Probably get to work out by the ID.So if you ever seen, if you go to a blog post, andyou guys have probably built stuff like this already, you have UUIDs, right?You go to a blog post, is that long hash.That's the ID.That lives in the URL query.We could extract that cuz we wanna know if someone on our website,our app clicks workout one versus workout two.We wanna make sure that we direct them to the appropriate workout.So what we can do is actually retrieve that parameter from the URL,and we can do that using chi.So here we can do paramsWorkoutID is going to be chi.URLParam,we're gonna pass it that pointer to r, andthen we're gonna extract the slug, which will dub as id.And we define the slug when we define it in our routes.Here, following,can just do some preliminary checks if paramWorkoutID is empty, okay?We can just simply respond, hey, this doesn't exist.Can do http.NotFound, okay?w, r, and then return.The return is absolutely critical.If you don't put a return continues.Now that we have the workoutID,the one gotcha is when we use chi.URLParam, it returns us a string.WorkoutID is not a string.WorkoutID is going to be an int for this example, okay?Now, typically this could be something like a UUID, that's probably more valid.For the sake of this course, we're gonna stick to using an int,just because when we start querying, posting, updating,it's easier to put one or two versus a UUID string, okay?So just for the sake of teaching, it's a little bit more digestible,I guess would be the best word to use.So here we're gonna do workoutID, and we're gonna do error.I'm gonna bring in a new standard library package calledstring conversion, so S-T-R-C-U-N-V, okay?And the function we're gonna do is parse.I'm gonna bring this one cuz my editor, >> Melkey: And do parse int.>> Melkey: There you go.Okay, so parse int.It's going to take an argument, which can be the params or workout ID,which is type string.It's been converted to base 10.It's been converted to a 64 bit int.Here, if our error does not equal to nil,what we're going to do is, I'm gonna kind of cheat this oneI'm going to do http NotFound, w, r, and return, okay?I know some individuals may have questions about error logging and stuff like that.Hold those questions until we're done, allow this module.I'm taking a lot of liberties right now to kinda get a dirty version of working andwe'll follow it up with properly formatting this,giving the proper utils and how to handle errors accordingly.So now if we have no errors,we know that we have successfully converted our workout ID and we have the workout ID.All I wanna do is format.f, printf, we can do W,and let's just say this is the workout id module OD,break the line, and let's put workoutID.Cool, so TLDR, here we call this.We have a slug.We extract the slug, we respond with the slug.Let's all read about it right now.Okay, as you finish writing that up, I'm going to start on the second handler.Don't feel rushed because this one is gonna be even easier.So all I'm gonna do here is handle CreateWorkout, not by ID cuz when youcreated workout we did not care about this, we handled this on our side.We'll do again the ResponseWriter, a pointer to http RequestAll I wanna do isformat We handled this on our side We'll do again,the response writer a pointer to HTTP request, okay?And then here we're just gonna do is format.f,printf, we can do W, and we'll say created a workout,just to tell us how things are working, cool.Now that we have our handle workout, the struck,we want to essentially allow people to curl these requests, right?We want to get and do a post.How do we do that?In routes, we can put in routes, but even if you put in routes,how does routes know about these functions?And this is where that structure of our app comes back.So here we have our type application struck,what we're going to add onto this is now a new field called WorkoutHandler.And this workoutHandler is gonna be a pointer to API workoutHandler like this,and so we're gonna pull in that package, we just created,melkeydev then project, internal/API, all right?And over here, we gonna create our stores will go here.And then right below it, our handlers will go here.And we can define our first handler as a workoutHandler as api.NewWorkoutHandler.>> Melkey: And once we define that, we can feed it into our application like so.>> Melkey: So I'm hoping that the structure is now becoming a little bitmore obvious, right?We're gonna have multiple handlers, workout users, whatever you want, andthere's a kind of exist in their own package realm.The way we bring them in is using our application struct to be this kind of onecrux that now has the ability to be called throughout our application.We pass that application shrug.So instead of passing each individual work on handler across to routes.gowe just pass app and that app has access to all of the underlying fields, okay?Now we have this.We can go to our routes.go, and very easily,just hook this up to our functions.Gonna be two function we're gonna add.We'll do r.get, okay?The first one is going to be the slug.So the workout, so we do /workouts/.And then this how you do a slug in cheese specifically, it's curly braces Id, okay?And then the function is gonna be app.workoutHandler.The thing we just passed into our app struck, andit's going to be HandleGetWorkoutByID.>> Melkey: Okay, once you finish that up, the next function is going to bethe createFunction, which is gonna be a post, r.post.The path is just going to be /workouts.And in here, I'm gonna app.WorkoutHandler,handleCreateWorkout like so.So if we're done with that, we can just quickly go back to our server,go ahead and rerun this again, okay?And now we can validate those new working paths.So here we can do curl localhost:8080/workout/2.You can see this is the workout id 2.And if you want to try out the POST method,you can do curl -x POST localhost:8080/workout.And you can see here, created a workout, so we have full confirmation, andnow our workout handler is routed correctly.We're able to query the routes and they work as we expect.

5.0 Data Layer
1h 35s
5.1 Postgres Database Docker Container
02:39:06 - 02:46:17
>> Melkey: So the next part we're gonna do is starting to poke at our database.I said that typically I like starting from the lowest level and build my way up.We started with the API layer, now we're gonna start working in that store file,that database layer, a clear problem is we need a database.So we're gonna create our database here.The First thing I want you to do, if you don't do this,you might have a pretty unfortunate situation if you do a git push,not the end of the world, but I want you to touch dot git ignore.>> Melkey: Now and git ignore we're gonna do slash database andI'm gonna also just database like, so just to be safe.And this is basically going to ignore any database valuesthat we are gonna create in our local environment here,and so they don't get pushed up to get home, that one be good.All right, now the next fog gonna create is the doctor compose file,I'm always excited for this.At the root of your project, let's go ahead andadd a new file Docker dash compose dot yml.>> Melkey: Now, if this is your first time using Docker, like I said earlier,the best explanation I have,it's a black box that runs software that doesn't actually exist on your computer.What your computer is aware of is Docker andthe software that lives within Docker is containerized within Docker.We're gonna do a few things that kind of bridges the black box ofDocker onto a local machine, which is persisting and having volumes, all right?But we're going to use Docker to have our database.And I've used this, I don't want to say trick, because it's not a trick, but I'veused this approach for local development for many, many different years.It's a quick, cheap way to spin up a Postgres database on your computer,and it's 14 lines of code, all right, so, and that's not including spaces,spaces, it's more.But here we'll start in a dogged compose just it's say the version I'm using,version 3.8 okay?That's probably an outdated version, but it's not broken, don't fix it.Here we'll specify the services, andwe will name the service DB for database, okay?The tabs do matter a little bit.>> Melkey: Okay, so the first thing we'll put is the container name, andwe call this just workout Db.>> Melkey: Okay, and next the most important argument is the image.Now, we have a black box, how does it know what software to run?That software is identified by the image, okay?The image tells Docker, hey, pull this software, the snapshot ofthe software into your Docker container and you're going to run it.So here, I'm gonna use a fairly older It's not that old, but it's old.It's not the cutting edge version of Postgres.You can, it's not going to be a problem, again, Postgres is extremely reliable,it's extremely backwards compatible.So do what you have to do, I'm using version 12.4 and to specify the image,we just type in the name of the software, Postgres, okay?12, dash or 12.4 slash alpine.>> Melkey: So this is telling exactly what snapshot version of Postgres we wantour Docker container to use.Next up, we're gonna define the volume.Now, the volume here has a particular rule.If we don't specify a volume, and it doesn't persist, every time we run up anddown our database, we wipe everything, which is not the best experience, right?If you wanna store some users or Developing.It's gonna mount a volume.This volume is going to be mounted in our database location, andthis is we're specifying this, doesn't necessarily exist right now, butwe're telling Docker this where you can mount the volume to.Postgres dash data, colon slash,after the colon is where it's gonna exist In the Docker container.So that exists in /var/lib/postgresql/data orto give it read/write abilities.Next, we're gonna specify the ports.So this is telling Docker, you can use this part of my actual machineto port it on your actual Docker container or the Docker instance.We're to use 5432 and bind it to 5432,which is the default that Postgres uses, okay?And here we're gonna supply with some environment variables.These environment variables are going be Important,because gonna tell us how to basically log into a Postgres database fromnot only our application, but using psql as well.So here we do Postgres underscore Db.When it says Postgres, okay?I'm gonna say Postgres underscore user, it's gonna be Postgres as well.Postgres underscore password,postgres, okay?And then one last command is restart unless stopped.>> Speaker 2: The restart should be one tab in, right?Or is that one out.>> Melkey: That one's out.The resource is not in the environment.>> Speaker 2: Okay, and then, sorry, the port,I always forget this with Docker, is the first one the Docker port?>> Melkey: No, first one's our port.>> Speaker 2: Port, okay.>> Melkey: Yep.>> Melkey: And the same applies to volumes as well, right?The volume is on the left side of the colon, it's what we're giving Docker andin the right side is what Docker is going to be binding it from, it's on container.>> Melkey: Okay, cool, so now you have that Rin,we can take a quick moment to see if it works.So here, if you have Docker installed and Docker Compose installed,you should be able to write, Docker Compose up-build.So docker space compose space up dash dash build.So if I run this you.You can see here,we now have a working Postgres database running on our Docker container.
5.2 pgx Driver for PostgreSQL
02:46:18 - 02:55:48
>> Melkey: I think it's pretty cool that we have going on here,we have our back end, and we have connection to this database.Well, that's actually not true, we don't have true connection to this database, butwe do have a running database, all right.So we're gonna go ahead and open up another tab, because we should have,depending on what your style is on my personalmachine I have three tabs occupied.One with the editor, one with go dot main running, and then one with Docker.And then I open up this new one so I can keep importing stuff and exploring.When like I just said, we have Docker running, we have a database connected butthis database is just, there's just chilling.It's just it has no affiliation to our project whatsoever,all because it's defined in the same project route, it doesn't matter.So here we're going to connect to that database, all right.And for us to connect to that database,we're gonna actually introduce a new package into our our project.And it's essentially a driver, it's a Postgres QL driver,the one that I recommend is by Jack C, and it is called pgx, okay?So it is a Postgres SQL driver and toolkit for go,it has about 11.4000 get up stars.It is relatively actively maintained, you can see a couple weeks ago,also written in Go.It's a pretty powerful driver that we are going to install anduse in our project here.Quick side note, this particular driver,this package, if you are on an LSP go PLS.It sometimes bugs out and asks you to reinstall it, orinstall a particular version of it if you put in other packages.I think we'll see this in this course here, it's not a deal breaker,it's just very picky and a bit opinionated.But yeah, pgx, what we're going to use against just going to be our driver.So here we're gonna use version four, so we're gonna do,go get github.com/jackC/pgx/v4/STD lib, standard library.>> Melkey: Going back to our editor within the store folder,add a new file, and this file is going to be called database.So database.go and we're actually gonna write stuff inside,so we can declare our package store.And the purpose of this particular file is going to allow us toconnect to our running database right here, okay?The way we're gonna do this create a new function, so func open.And func open is going to not take any argument,but is going to return a type sql.db, andan error to bring in the SQL package.It's standard library import,you can do database slash SQL >> Melkey: Andthen here we're going to basically instantiate a databasestruct that we're going to use throughout our application,so here we can type db err is going to be sql.open.This whole argument here is the connection string we're but the very first argumentis going to be the driver that we're using, and we just installed pgx.So here we can do pgx, and now this is gonna be an interesting property in Go.Like I said, if I do FMT, the compiler yells at me, you don't,you're not using FMT, right?But I could just do this, because there are certain cases like the onewe're going to see now with JAXI pgx where we don't implicitly use the library.But we are using, or we don't explicitly use the library, but we are implicitlyusing it via this pgx connection string here in the SQL open method.So here we're going to bring in github.com/jackC/pgx/v4/STD lib,it's gonna yell at us and in here we're going to just ignore that.>> Melkey: Let me just go close all this.>> Melkey: Yeah, there you go, so it just bugs out, so I have to do an LSP restart,I'm wondering if anyone else, does anyone else get that or you guys,it's kosher on your side?Good, yeah, so depending for me, on U of M with my configuration, it does bug out,but it Is working as expected, but thank you for being patient.Okay, next is gonna be the actual connection string, sohere we'll do host equals, it's gonna be local host, okay?The user is going to be Postgres,the password is going to be Postgres,the db name is going to be Postgres, okay?And in here we'll do port 5432, the one we specified in our Docker compose file,and then we'll just add SSL mode equals disable.>> Melkey: I'll zoom out just a little bit so you,you can see the entirety of the connection string andmake sure I don't have any typos.Host localhost, user Postgres, password Postgres, dbname Postgres,port 5432 and SSL mode disabled.Next up, let's check that error, so if error does not equal to nil,what we're going to do is return nil.And here we're going to do format.error f, and here we'll say db,open method modulo W and pass in that error, right?So another format specify that we haven't seen before.Otherwise we can do format, print line, and we can say connected to database,instead of returning nil nil, we're going to return db.>> Speaker 2: In a production app,where do you typically store your database credentials?>> Melkey: Not in code, for a connection string,I would typically store them using AWS secrets.I actually am not a fan of doing.env files, I think they are highly dangerous.And so, I prefer to handle that burden with a proven service, like AWS client,secret manager, something like that, and then you pull it down.Dot env files are good for something you're building locally,I personally believe there's more condom pros with them.Okay, let's go back to the application and actually start using this db,so let's go ahead and create Postgres database error.I'm going to store.open, soI bring in that store mod package we just created, check that error.So if error does not equal to nil, let's go ahead andreturn nil and the error, and then in our application struck,let's go ahead and create a new db field.It's gonna be sql.db, like soyou can see pgdb is yelling at us or the compilers killing in us.We'll just put db as pg, db like so, sonow our application struct also has access to our database, okay?And this will work as is, but there is one criteria that we need to be aware of,and that is like loose connections and open connection with the db, right?So we want to make sure we close this, now,Go offers a pretty cool way of handling things like this.So if you go back to our main.go,right underneath the arrow does not equal to nilwhere we declare app, we can do app.db.close.Now, if you look at look at this, this will make no sense,because the db will close before of any ways of accessing it, right?But what we can do is use the built in defer function from go.And this built in defer function tells our application at the very end of execution,everything else has been done, then go ahead and call this function.>> Melkey: So we defer it until the end, hence the name, very good, so now,with all of that, we can nuke our running go instance.If we do go run main.go, you should see now that we are connected to our database,and we are still running on port 8080.So now we have a clear connection between our back end and our database,even though it's not obvious, we only have this little print statement.We will see in the next sub module how we're actually going to load upour database with tables.How we're gonna explore them with psql, andactually explore data that we persist, read and delete.
5.3 SQL Migrations with Goose
02:55:49 - 03:13:08
>> Melkey: So building off of everything we've done so far,we've created our backend, we've created our database.We have a few things running, it's looking good, and we have the connection, butit's not the strongest connection.I'm gonna introduce another really good package, and this is called Goose.Goose is a database migration tool.It supports SQL migrations and Go functions.If anyone has ever dealt with migrations,just going at it, that is a very unfortunate experience.Migrations are notorious for losing data, breaking databases,and, unfortunately, just taking souls.Because if you're not properly equipped, whether it is not making backups,not having the right tools, just misaligning on your infrastructure,on your initial schemas, you can possibly run into some really nasty consequences.So I found this tool a while ago, andthis is recommended to me by a very very brilliant engineer.It's called Goose.And it's a migration tool specifically for Go.And what migrations are for those who may be unfamiliar with the lingo.A migration is used when we have to make a modification to the underlyingschema structure.So when you create a database, and you have a schema, unless it's a user, andit has a bunch of fields, but let's say, down the road, your project blew up,and a new feature came in that your users absolutely want,that requires you to modify that database schema.Well, you can't just add a column and then what?How do you run that? How do you run that SQL, right?Or, if you have to add that column, and it had breaking changes, andyou have to revert, what do you do?So goose allows us the ability to migrate between versions of our database,so it allows us more flexibility and an easier way to run SQLthat does the underlying changes to our database, okay?Now to install Go or install goose,it's a bit different, we've previously seen we did Go get.Go get is specifically used to just bring in a package into the scope ofour project for our go.mod and our go.sum.In this one, I would like you guys to install goose, and the reason forthat is goose is going to be applied to our binary, to our GoPathBin, directory.Because we're going to use the goose command.Okay, so I'm gonna copy this command over to the terminal, sohopefully it's a bit easier to see, I'm gonna clear this.So let's go install github.com/presley/goose/v3/cmd/goose@Lat-est, to get the latest version of goose installed.So I'm gonna go ahead and click Enter, soI already have installed to make sure you have installed,please do goose version, or goose-version.Is anyone getting any ZSH or script not found?Okay, so to solve that is open up a terminal, first of all,you wanna make sure that it's installed correctly.So you can do the following command to check firstif it's installed, it's a grep command forgoose so that makes sure that exists in the go/bin.If you have that, that's a pretty easy fix, all you need to do is export orrun this command, export PATH=$HOME/go/bin:$PATH.Export that into your ZSH or bash script,whatever it is, we're gonna have to write some SQL.I know you guys want to do a go course, but because we're doing a back endapplication SQL, you cannot get too far from SQL in the back end already,eventually you're gonna have to do it.And we had a question earlier, if we're going to use RMS, no,we're gonna write this raw, all right?So, at the root of your project, let's go ahead and make a new folder,let's call this migrations, okay?And the first file we're gonna create is fs.go.This fs.go file is going to look a little wonky, so first,let's go ahead and declare our migrations package.And over here, we're gonna import the embedded library, embed.And what we're going to do, we're specifically reserving this file forwhen we compile our application to binary.Because what this tells us, fs is going to be a file structure,and what we're going to tell our compiler is that there's going to be a bunch of SQLfiles that exist in this file structure we're going to create.And then when we use this downstream, we actually run our goose migration up inour application, it's going to refer to the file structure here, okay?So I'll show you what I mean, so we do this Go build command soit's commented out, and then go:embed, and then here we're gonna do wildcard.sql.This is saying,find all of the SQL files that are going to exist in the directory path here.I'm gonna create a new variable, var FS, and it's going to be embed.fs,you can see it's a read only collection of files, usually initialized witha go embed directive, and that's it, that's all this file is going to do.We're going to capitalize it because we're gonna pull in FS, but essentially,we're going to be building a bunch of these files into this variable, okay?Now comes the fun part, in migrations, add a new file,the syntax of this doesn't really matter, I'm gonna share with you what I use.I use 00001, and it's gonnabe called _users.sql, okay?So here we're gonna ship right SQL, butfirst we're gonna actually give it some goose command, some goose directive.So we need to decide to do a comment SQL file--plus goose up,which says on up, do the following, note that.We'll do plus, want to saygoose statement begin, okay?And here we'll do create TABLE IF NOT EXIST,I'm gonna fix this extra space here.The name of the table is gonna be users, all right?And here we're gonna define what that schema looks like, sowe're gonna have a field called ID, BIGSERIAL,It's gonna act as our primary key, okay?We're gonna have our username, it's gonna be a VARCHAR.I didn't put the most effort to thinking about the size of a username,I just put 50, I'm sure there's more optimal ways of handling this.For me, I just put 50 here, and it's gonna be fine, I'm gonna make surethis is unique and not null, meaning every entry in the user's SQL database isgoing to have to have a username and that user cannot be a copy of someone else's.We're also gonna have another field called email,I'll make this one a bit longer, VARCHAR(255), oops, okay?Now we can make this UNIQUE NOT NULL as well,here we'll do password_ hash.So this one's gonna be pretty important, we are not going tobe storing the actual hash of like, the actual password, right?That's not what we're going to be doing at all,we're gonna be storing a hash representation of the password.I'll show this down the line, we don't have to worry about this too long or yet,we'll make this 255 >> Melkey: 255 andwe'll make this not null, okay?And then here you can just add any fields you want, right?This could be just extra fields, I'm gonna put bio to make this a text,I'm gonna create a created underscore at field.It's gonna be a TIMESTAMP WITH TME ZONE,I'm gonna put default to current underscore timestamp,which is a built-in function for Postgres.And I'm gonna also have an updated_at, which can be the same thing,TIMESTAMP WITH TME ZONE, DEFAULT CURRENT TIMESTAMP.>> Melkey: When you do that, make sure to end the statement, so StatementEnd forgoose, and basically what that blog does is when we run goose up,this is going to be the SQL that gets run depending on the version of goosethat we're currently running at.And with every up command, we just also need a goose down command, sowe'll do goose down, we'll do +goose StatementBegin, and this is pretty easy.We just do DROP TABLE users because if you think about it, this is the role beforethe users table exist and when we go back to it whatever that looks like, okay?And here we'll do +goose StatementEnd, cool, now,what I'd like you to do is go ahead and copy this.I'm gonna make a new file, it's gonna be 00002, andthis is gonna be called workouts, so workouts.sql.Go ahead and just paste this because we're gonna repeat a lot of stuff,and it doesn't make sense to just copy the same thing over.So goose up, goose down begins to be the same thing, create table,if not exist, not users but workouts.The ID is still gonna be a big serial primary key.Now, this whole project is allowing users to create workouts, soif you've ever worked with relational database,a workout has to be tied back to that user.Here's the thing, I'm gonna make this not obvious, we're gonna ignore that for now.The reason why is because I wanna focus on first getting everything working withworkouts, and then we're gonna introduce the user, andthen we can tie it back into users owning workouts.So for right now, we're gonna make a mental little note of a comment,I'm gonna put user underscore ID.>> Melkey: Our workout is gonna have a title,which would be VARCHAR(255), NOT NULL,we're gonna have a description, which is going to be text.We're also gonna have a duration_minutes,which are going to be INTEGER NOT NULL, andwe're gonna have one more field called calories_burned.And this is also gonna be an INTEGER, and we don't care if this is null, and thenyou can go ahead and remove the username, email, password hash and biofuels.So double check that your end result looks something like this.>> Melkey: You should have a workouts table ID, the commented out user ID,title, description, duration minutes, calories burned, andthen the created and updated at timestamps >> Speaker 2: You wannadrop workouts instead of users?>> Melkey: Yeah, we're gonna drop workouts>> Melkey: Okay,let's do that one more time, go ahead andgo to the top of your file, copy everything, and in migrations,we're gonna make our last SQL file, have four zeros, so00003, and this one can be called workout_entries.sql.>> Melkey: Just paste this here, andI'm gonna explain the dynamic here of what a workout entry is versus a workout.So a workout is going to be an umbrella, high level description of the workout.It's gonna have the title, duration and things of that nature, buta workout could have many different workouts in it.Someone could be doing leg day, could be the title of the workout,but then they could be squatting, they could be lunging, they could be running,they could do calf raises, they could do all these different things.And each of those is going to be an individual workout entry, sofrom a schema perspective, we're gonna have a one-to-many relationship here.One workout can have many workout entries to them, right?>> Melkey: And all those workout entries are gonna have only one relationship backto a workout.>> Melkey: Okay?So with that being said, CREATE TABLE IF NOT EXIST,instead of workout is gonna be workout_entries.It's gonna make some space here, the ID is still going to be big, serial primary key.We're gonna have a new field called workout ID,it's gonna be big hint, all right?Not null, and going to references, I'm gonna pass in ourworkouts table like so, and the value is going to be ID.So the work at ID here references the ID of our workout, andwe're gonna do ON DELETE CASCADE, meaning if we delete the workoutfrom the workouts table, all of the worker entries that are bindedto it via this relationship will also be deleted, okay?Next field we're gonna have is the exercise name,this would be a VARCHAR(255).Make sure this is not null, and we'll have sets,this will be an integer, not null.We'll have reps, make sure this is an integer.Okay, we'll have duration, underscore, seconds, we'll make this also an integer.>> Melkey: [INAUDIBLE] I have weight for the individual workout,we'll make this a decimal value.>> Melkey: We'll add an optional field for notes, this could be also a text, soif anyone has like PR, or personal record or, I mean, personal dash, whatever,they can add into the notes section.And then another field that's gonna be crucial is order index,this is because if somebody has a workout with five different workout entries, wewant these to be ordered to mimic exactly what that user did in the workout, right?If you submit a form with all those entries, we wanna adhere to that andnot just jumble them around.I'll make this INTEGER NOT NULL, then go ahead and copy that created at timestamp.So at this point, your SQL table should look similar to this, sowe can ignore the goose down for now, let's save that to the end, okay?I think this is cool, we're gonna add a constraint,I'm just gonna add a constraint.Oops, make sure, expel the right constraint on our Postgres,I'm gonna call this valid_workout_entry and this is gonna be a check.And in this check, we wanna make sure that if somebody submits a work at entry, thiscould either be them lifting or running or doing some non lifting exercise.So for example, if you're going to be bench pressing,that's have reps, right reps and weight.If you're gonna be running, though, you can't really rep running, butyou can do duration, you can tell us how long you ran for.So we're gonna make sure that there's a constraint andnot a workout entry can have both of these fields, andevery workout entry must have at least one of these fields.So how that looks like is, reps IS NOT NULL ORduration_ second IS NOT NULL, andwe'll make another constraint here,REPS IS NULL OR duration_second IS NULL.
5.4 Running Goose Migrations
03:13:09 - 03:20:39
>> Melkey: We are almost there.All we have to do is kind of route our application to then readthe file structure here.That goose up command, we're gonna run it in our application first, andwe are gonna run it in the database.go file.So if you go back to your database.go, again, ignore this little error here.I'm gonna have to restart my LSB.>> Melkey: Underneath our open function, we're gonna create a few more functions,or two more functions.The first one is gonna be called migrate.So we're going to do func migrate.This migrate function is going to take two arguments.So dg, so we're gonna pointer sequel.db.>> Melkey: Okay, it's also gonna take a directory, which can be a string,and it's going to return an error.>> Melkey: Like so.>> Melkey: So this migrate function is gonna have a very simple purpose.It's gonna tell goose what database we're using, andit's also going to tell it exactly what we want to do, which is run goose up.So here we can do error,is going to be goose.setdialect, like so.It should bring in the goose package for you, okay?I have to make sure mine is v3.We do actually have to bring it into a project, because we installed it to havethe goose command, but we also to do a Go get on the command now.So if you do go back to goose, instead ofdoing Go install, let's also run a Go get.Okay, cool.Now you can see it's imported as goose and not used.So now I know there's no import issue, it's just, the compiler is yelling at me,which I'm fine with.So here we'll do goose.SelectDialect.And this is basically telling goose what we're using,which is going to be Postgres.Like so, we'll check if error does not equal to nil.We're going to return fmt.Errorf, okay?I'm gonna say issue with migrates.We're just gonna say, migrate, >> Melkey: Modulo w,them and pass in the error.Okay, next we're gonna do error.I'm going to equal this to goose.up.We'll do goose.up, I'll pass in the database and then the directory.>> Melkey: If error does not equal to nil here,all we're gonna do is return fmt.Errorf.All right, I'm gonna say, goose up module W, pass in the error.Like so, and then we'll just return nil.There's no errors at this point.Okay, now, the last part we gotta do is be fairly quick.We have to now bind in that FS, that file structure.So all we've done so far is tell goose what we're using and what command to run,which is goose.up.The last part is to bind that migrations package we have.So here we'll just call this MigrateFS(), okay?It's going to take sql.db.It will take MigrationsFS(), which is going to be of type.fs,we can bring this into our library using IO/FS.At the top there in the import statements.And I'm goinna bring in our directory string.And this is gonna return an error for us.>> Melkey: Okay, so here we're gonna set a function.We're gonna set the base file structure, andthen we're actually gonna call the Migrate function we wrote below.So here we'll do goose.SetBaseFS.We'll put in the MigrationsFS, like so.And then we're gonna create a defer func, an anonymous function.We'll do defer, which we've already talked about, andthen we'll create our anonymous function func, right?The body of our function here,which is gonna be just goose.Set Base back to nil.This does not require any additional arguments,which is what these parentheses will mean, okay?And then, we'll return Migrate like so,I'm gonna pass in our DB and our directory.Cool, okay, so now we have MigrateFS.We have Migrate.The last part is to hook this all up into our app.go.So if we go into app.go, >> Melkey: Okay, the onlypart that I think would make sense to add this is is right above the logger.And here we can do, error is going to be store.MigrateFS,when it passed in our database, pgdb.We're also going to bring in our migrations package, so migrations.fs,that variable we declared.So, .fs, okay?And then the directory is going to be just dot.So we're gonna be running this from the base of our directory.That's where we can find the migrations package for goose here.>> Melkey: Now, if error does not equal to nil, we can just panic.Cuz if our database doesn't work,application definitely should not work as well.>> Melkey: There's one more thing I want to do, and that's gonna be to run this.So we have all these migration files.We've set them all, and they look like they work.Now, if we go back, we should still have, let me see.Did I bring it down?I did.So here, let's bring everything down.And what I want to do is, again, let's go docker compose build up.>> Melkey: It's gonna run our workout DB container.And then here, if you run Go, run main.go.You should see we have a few things.Connect it to our database and we have these three okays, okay?For users, workouts, and our entries.And you should see now, successfully migrated database to version three,because we have three SQL files, all with the goose statement begin andgoose up command.One more thing that we can do is now we can actually use PSQL, right?So this is the thing, you can use any kind of DBUI that you'd like, butPSQL is the one I use.Here's the command- usual be Postgres.The host is localhost, and the port is 54 through d2.So if I run this, it should ask me for the password for Postgres.That's just Postgres.If I run this, you can see, PSQL version 17.4, server 12.4.That's important because that's the image that we have.And now if you do forward slash DT, you can see that we have our users table,our workout entries table, our workouts table, and the actual GooseDB version.So we've kind of completed the loop here of now having our database spun up,our back and connected to our database, andus actually inserting new SQL schemas into the database itself.
5.5 Defining Data Types in Store
03:20:40 - 03:29:12
>> Melkey: We've closed the loop on a bunch of different things here.We've set up a lot of the project here.We have a database, a lot of things for the backend communication here.And we're gonna take this just a few steps further.We might get kind of halfway through this kind of submodule.But the part that we want to focus on now is if we go back to internal,into store is now we are fully equipped to start working in the workout store, okay?And the reason why I'm excited forthis is the workout store is going to be the section of our application where we'llbe doing logic that communicates with that database.We'll be again writing SQL, we'll be doing all that scary stuff that peoplefreak out about, like SQL injection.All of that is going to be all defined here.So like always, when I look at a file, especially a new package,I ask myself, am I going to handle data?The answer is yes because I'm going to be communicating to a database.If the answer's yes, I typically think of a struct.So here we're gonna create our type Workout, it's gonna be a struct, okay?And this struct is gonna have many different fields.The first one's gonna be ID of type int.It's gonna also include this json tag, okay, this is called a struct tag.Go allows a bunch of different struct tags on fields of structs, andthey all have different purposes.So the json one helps us for encoding and decoding JSON into a struct.So if you get a payload from our frontend that has a JSON that matches this tag,we can easily decode that into our Workout struct and vice versa.So here we can do ID.The next field we're gonna have is Title, whoops, string.>> Melkey: Like this, we're gonna also have a Description.>> Melkey: All right, we're also gonna have DurationMinutes,it's going to be an int.>> Melkey: CaloriesBurned, and this is gonna bean int "json:"calories_burned.And now the last field we're gonna have here is Entries.And Entries is going to be a slice of a new structwe're gonna have called WorkoutEntry, okay?And here we'll just put it as entries, like so.Our compiler's gonna yell at us, rightfully so,we don't know what a WorkoutEntry is just yet.But we can easily change that with type WorkoutEntry is a struct, okay?Int should follow a lot of those same parameters, so ID int json:"id".We're gonna have our ExerciseName,it's gonna be a string, "exercise_name".Sets is going to be an int, I'm gonna do that as json:"sets".Now the next fields are Reps, and Reps,because of the constraint we said earlier in our SQL,this is actually gonna be a pointer to an int because we wantto explicitly check Reps for being nil or naught, okay?So here we can do json, it's gonna be reps,have DurationSeconds, okay?It's also gonna be a pointer to an int,duration_seconds.>> Melkey: Okay- >> Speaker 2: Typo on seconds.>> Melkey: Yes, [LAUGH] thank you.We'll have Weight, which will be a pointer to a float64.>> Melkey: Weight, and then we need two more, soNotes is gonna be a string json:"notes".And then the last field is OrderIndex, right, soOrderIndex, and this is going to be an int json,write this as order_index, like so.Now we have our two structs, great.So we have these two structs, I'm gonna quickly also now create something we'veseen before, which is going to be the handler equivalent.So I'm gonna type PostgresWorkoutStore.This is gonna be a struct, so a third struct, and this is gonna hold db DB.Now why, what is this, what is this thing, why is it called Postgres?Tell Postregs we're using Postgres, end of story.However, from a pragmatic perspective, this is a really bad naming,right, because it directly says this WorkoutStore is bounded to Postgres, okay?What if one day we use Postgres, but the next day we have to use MongoDB?What if we get a new CTR company and they say, hey,absolute to move Postgres we have to use this other database.But we're completely bounded by PostgresWorkoutStore right?But there is a good solution to this.Before I show the solution, I also wanna just finalize the constructor forthis PostgresWorkoutStore.So let's go ahead and create func NewPostgresWorkoutStore.I'm gonna say this is a db sql.db, andwe'll just return a PostgresWorkoutStore like so.And here we'll return an address toPostgresWorkoutStore {db: db}.Okay, now back to the PostgresWorkoutStore.So yeah, what happens if we have to switch databases?That happens a fair amount of times, right, like new constraints, new features,what do we do?It'd be a real shame if we have to go back andrename all the instances of Postgres to something else.Well, luckily for us, Go gives us the ability not to have that.And this following thing is called essentially decoupling our database.But what we're going to use is an interface.And an interface is simply a collection of method signatures, that's all it is.It's not a new type, it is not a function.It is literally a collection of method signatures.And when you have something that satisfies all of the method signaturesin an interface, you can use that type as that interface type.So I'll demonstrate here, we do type WorkoutStore now as just an interface,okay, until we spin this up with two functions, CreateWorkout.CreateWorkout's gonna take a pointer to a Workout,and it's gonna return two things, pointer to a Workout and an error.And it's also going to GetWorkoutByID and it's going to take an id of int64,and it's going to return a Workout or an error.>> Melkey: So right now our interface is complete.This is it, this is how it's going to look like.But if you notice, our interface is just called WorkoutStore andwe have PostgresWorkoutStore.So right now, even though we're bounded to our PostgresWorkoutStore and we'regonna have our logic that communicates to our database using Postgres native things,it doesn't mean that our application layer also needs to be changed.Because our application layer, it's going to accept the WorkoutStore interface.It is never going to accept directly the PostgresWorkoutStore struct, okay?We're gonna define all the logic using PostgresWorkoutStore, right,cuz that's what we're using to make sense.But if it comes to migration, all we have to do is make the relative functions forthis new database, but that's it.The migration's containerized in this data store layer.Our application layer will not care, it won't even know the difference becauseall it's going to do is communicate via the WorkoutStore interface.
5.6 CreateWorkout Query
03:29:13 - 03:39:46
>> Melkey: So we're gonna create a light to, it's two functions, butone is like a gimme.The one that actually matters is going to be the CreateWorkout.So we're gonna do a func, we're gonna set a method receiver as pg, andthis is gonna be our PostgresWorkoutStore, I'm gonna call this CreateWorkout.Now, the CreateWorkout we are about to define with the arguments andthe return have to be the exact same that we defined it in a few linesabove to the create workout interface method up there, okay?So to do that, we'll just do name is gonna be workout, butthe type is what really matters.It's gonna be a pointer to workout, okay?And just like our interface dictates, it has to return a type Workout ora pointer to Workout and an error, okay?So here we're gonna actually get pretty deep into the SQL.Here, we're gonna start a transaction,tx error is going to be pg.db.Begin.This is gonna tell us we're gonna do a transaction which we can commitat the end.The reason I wanna commit this transaction at the end is because our workout is notonly gonna have it's own workout property, but remember all those one too manyrelationships, those also need to be committed into the workout entry database.And if something happens in between, let's say we're about to commit our workout,something like freezes our communication channel andwe don't have the workout entries, we're actually going against assetprinciples in database communications, right?So we commit at the end and if something were to happen,we actually have a function that allows us to rollback.So what does that look like?So here, if our error does not equal to nil forwhatever reason, we can simply just return nil and error.However, we're gonna do a defer transaction rollback.So if anything happens in this function that causes it to just die orcause anything to error out or any kind of nasty things,we can roll back that transaction to a state before we call this function.>> Speaker 2: Do you defer on that,wanted to call regardless though when X is the function?>> Melkey: What do you mean?>> Speaker 2: That's misunderstanding.So if we defer the rollback.>> Melkey: Yeah.>> Speaker 2: And then we do the insert statement, right?Everything goes well, we leave the function, won't rollback still be called?>> Melkey: Yeah, because we have this active transaction,this tx, we're gonna be using tx with a bunch of our queries.So we're gonna use tx dot query row a few times.And let's say, in between the two transactions, if we do two methods onquery row, something happens, it's going to collect that into the tx struct.So here, this returns tx,tx is a struct with all these kind of things here, and it's gonna kind ofcontinuously collect any errors in the status of our transactions.So when we rollback it's going to validate, if there's any errors,if there are it's says no and nothing essentially happens, butif it rolls back the transactions to previous day.>> Speaker 2: So do you commit then if there is no error in it->> Melkey: Yeah, soif there is no errors, you'll commit.>> Speaker 2: Okay, gotcha- >> Melkey: Andwe actually specify that at the end, we actually have to call tx dot commit.>> Speaker 2: Gotcha. >> Melkey: Yeah.>> Speaker 2: All right, thanks.>> Melkey: Okay, so here we're gonna get pretty nasty.We're gonna create query, we're gonna define our query, okay?Old school style, it's not really old school.Just INSERT INTO workouts andthe values we're gonna pass in are title,description, duration_minutes,and calories_burned.I'm gonna open this up cuz that's not the only thing I'm gonna beinserting into this or writing into the SQL, just like so, okay?Then I'm gonna pass in the VALUES.So here post stress notation uses the money symbol,$1, $2, $3, and $4.The reason why it's four is cuz we are inserting four values, title, description,duration, minutes, and calories burned, okay?And then we want RETURNING id that's correct, yeah.So we have our query defined.Here we're gonna do error is going to be our transaction,that tx that we've initialized, and we're gonna do QueryRow.And QueryRow is gonna take our query and all those values,the four values it expects.And how do we get those?Well, they belong on workout.So workout.Title, workout.Description,workout.DurationMinutes, andworkout.CaloriesBurned.And here we need to scan this, we do a dot method.So .Scan into the address of the ID that we wanna scan into,which is address.workoutID.I'm gonna zoom out, just everyone can kinda see the full query function here.Next always check the error, so if error does not equal to nil,we want to just return nil and the error, all right?At this point we also need to insert the entries.And so how can we do that?Well, if you remember entries is a slice, what we can do is for,ignore the index values cuz we don't care,entry in range workout.Entries like so.We now have the ability to gather the values of every individualentry that someone may submit with their response,with their payloads from the client or whatever.So here we can create another query in line like this.And we can say INSERT INTO workout_entries,and then the values we want to insertin here is going to be workout_id,exercise_name, sets,reps duration_seconds, okay?Weight, notes and order index.>> Melkey: Okay, this followed the same pattern we saw above.Next, have to pass in the VALUES.So VALUES, it's gonna be one because there's eight, workout id, exercise name,sets, reps, duration, weight, notes, order index, we have to do this eight times.>> Melkey: Eight.>> Melkey: Like so.And we can also do RETURNING id.Next thing we gonna do is just basically execute the query.We can do err is, again, our transaction, I'm gonna query this row.We're gonna pass it this new query and all of those arguments.So the first one is workout.ID, andthen all the other ones belong on the entry struct.So it can be entry.ExerciseName,entry.Sets, entry.Reps,entry.DurationSeconds, entry.Weight,entry.Notes, and entry.OrderIndex.>> Melkey: Okay, I'm just gonna zoom out, I'm gonna zoom back in real quick.The next thing we need to do is just scan this into entry.ID like so.Now last part, check these errors too.So if error does not equal to nil, let's go ahead andreturn nil and the error, right?And now, outside of that for loop for when we're ranging over our workout entries,here is where we're going to do error equals transaction.Commit.So commit commits the transactions forall of the entries that we've kinda queued up, okay?And in here we can do one final check,if err does not equal to nil, return nil and err.And the final return here to satisfy it all will bereturn workout and nil >> Speaker 3: My LSP is mad at me becausewe're not checking if there's an error forrollback, unless you check that I didn't get it.>> Melkey: We check error for rollback up here and then defer, I mean,at that point,this is where we could use something like just an anonymous function to defercreate error equals tx.rollback if error does not equal to nil, check that.I've typically used just for rollback my LSP, I thought my LSP was pretty picky,but I'm not getting that error, but- >> Speaker 3: Yeah,I don't know, that's weird, maybe it's just mine being odd.>> Melkey: That's weird mine even was not saying that, but it's cool that's yours.Are you using Go PLS?Wow me too, [LAUGH] okay.I'm gonna quickly just scaffold the next function.We're not gonna put a lot of logic into this, but we're just gonna make sure thatwe have the second function fulfilling our interface here,which is called get workout by ID.So let's quickly just create our function, make our method receiverthe PostgresWorkoutStore like so, and then let's call the function GetWorkoutByID.This function should take an ID of int64, and it's going to return two things forus, two types, our pointer to workout and the error.And within the function body, I'm gonna quickly just create a workout,so just create a new workout like so.You don't have to put any fields in it, you can just make it empty.And then one line below it, let's go ahead and return the workout and nil, cool.And the reason why we're doing this is because of our interface, all right?Which again, quick reminder, is defined right here.

6.0 API CRUD Routes
1h 24m 15s
6.1 CreateWorkout Handler
03:39:47 - 03:49:30
>> Melkey: Sweet, so with that created,we can actually hop back into our WorkoutHandler.So if you wanna go into the WorkoutHandler,this is in the API package.When we were querying these functions,we got preliminary kind of responses of created a workout, and we show thatwe can parse the slug from a query that we are hitting using Chi, right?We're using the params workout ID right up here.So we're gonna kind of up this up a little bit.We are no longer just going to return these random things, we're actuallygonna try and communicate through our client, to our API, to our database.I'm gonna start with our handle, create workout down here.So right now it should have just a simple print statement.Go ahead and just nuke that.We no longer need that.I'm gonna start off by creating a variable to store the workout, okay?So we can do var workout.It's going to be of type, store.workout, like so.And I'm gonna decode this.We're gonna declare an error, and this is gonna be JSON.So try to see if this is brought in.It's a standard package in Go, the JSON package.I'm gonna json.NewDecoder, okay?And we're gonna decode the r.Body.And just a quick reminder,r is the pointer to our HTTP request that we're getting from the caller.This could be client, this could be whatever it is, just us testinga different terminal, but the contents of the request are going to be in r.Body.And what we're essentially doing here is we are using this JSON package tofirst of all, create a strut for us that's going to parse the r.Body.And we're gonna parse the contents of r.Body into our workout here.So do .Decode, and then parse in the address of workout.>> Melkey: Now, the reason this works is because if we go back toour store.workout, we have our JSON tags here.JSON ID, title description, duration minutes, calories burned, and entries.So when we expect r.Body, the body of the request,it's going to have these JSON fields with the appropriate values.But it allows us to easily decode that content into our workout here,our variable that we declared just above.Let's go ahead and handle this error cuz our compilers matter to us.We can do if error does not equal to nil.We can do a few things.First, we're gonna quickly just do a fmt.PrintLn, I'm gonna say error, okay?This is not permanent, this is just for us as we build this out, okay?So if there's any unforeseen errors,we'll see this in our terminal that's running our Go server, okay?But this is not really a good way to handle errors,I'll show you how we can improve this in just a little bit.But I'm a fan of, let's get something working that does a preliminary job andthen we can improve on it.So with that, we now also have to handle the error for the caller, okay?So that first error statement is for us to see what's going down in our backend.This is to respond to the caller that tells them, hey,I couldn't process your request.So we can pass in the ResponseWriter w, andthe message could be failed to create workout, all right?And then the status code.So we can do http.StatusInternalServerError,also known as 500.Once you have that, please make sure you add the return, cuz if you don't,your client's gonna see the error message, butthen you're gonna continue on with your function.Which is something you definitely do not want to handle.Missing return series is pretty common, it happens, so just make sure you add it.Now, the cool part is, I have a question,if anyone has the answer right away let me know.But right now how do we have access from the scope of this function, from the scopeof this package, or API package page, how can we possibly hit the database?>> Speaker 2: Through the app struct.>> Melkey: Through the app struct?That's a pretty good answer, but it's not necessarily the app struct.It's actually gonna be through our WorkoutHandler struct, okay?So right now, when we first created, I purposely left it emptybecause I wanted to demonstrate how we can add on to this truck to do things forus that can kind of connect with other parts of our application.So here, the WorkoutHandler is just simply the handler forus to create these methods on.But now what we can do is, If we go up here, we can open up this struct andwe can include a new WorkoutStore, all right?Which can be of type store.WorkoutStore.And I wanna emphasize this part a little bit.WorkoutStore is what?Does anyone remember?>> Speaker 3: The database.>> Melkey: It's the interface.>> Melkey: The WorkoutStore is the interface, right?It's right here.And this is kind of the highlight I want to incorporate when we first created this.From the perspective of our API layer, all it knows is this interface.It doesn't know about our PostgresWorkoutStore orany of the methods and logic that we created on it.And why does this matter?Is again, if for one, whatever reason you have to swap your database,you have to of course always make the changes in your database layer.If you're gonna swap from Postgres to like Mongo or something else,that work has to be done.But from the perspective of your API layer,your API is not gonna have to change at all.As long as your migration from one database to a new one adheresto your interface, your API layer can be left untouched.Which I think is a very powerful thing, it's decoupling the database.And, yeah, we're gonna see how we can fully leverage that.So now that we have this struct, we have to also modify our constructor, okay?So now WorkoutHandler is gonna also accept a WorkoutStore argument,which if type store.WorkoutStore, all right?And then here in the return, you can just put wWorkoutStore is WorkoutStore,like so.>> Speaker 4: Can you, like in JavaScript,I think you can just use the variable if there's the same variable name andproperty name and variable name that you're passing to it.>> Melkey: You mean like kind of deconstruct it like->> Speaker 4: Just a shortcut to->> Melkey: Like that?>> Speaker 4: Yeah. >> Melkey: Yeah, you can do that.You can do that.I like to be very explicit even though I don't have to be.Okay.I think it'll also do the same with like structs and declaring structs.They're not to be explicitly declared, butI'm gonna be as explicit I can throughout this course.And typically, I think it's a good pattern, if someone looks at your code andmaybe they're not familiar with that, to be explicit, butthat's neither here nor there.>> Speaker 5: Is that JSON decoder the same or similar to unmarshaling?>> Melkey: Yeah, it's very similar.They have the decoder.They are very similar, you can kind of use one versus the other.On marshaling, from what I've seen, is better used for internal,kind of within your own application.If you're gonna have to do something with JSON, you kind of craft it andthen send it to maybe another package or something.The NewDecoder is typically what's seen when you are accepting json payloadsthrough HTTP or something like that.But I do believe you can use them interchangeably,I just think the NewDecoder is a bit more designed forhandling requests over server calls.All right, so now that we have a bit of our structure set up, what we're going todo is create a new variable called WreatedWorkout, and in error.And here we're gonna use wh, and you should see now a new field calledWorkoutStore, and then we can click CreateWorkout, okay?And we can pass in our workout like so.And this CreateWorkout is, in fact, the CreateWorkout function we just created inthe new PostgresWorkoutStore, but because we're using an interface thatsatisfies the method signatures, doesn't really matter.All right, and now, as always, let's make sure we handle that error.So if error does not equal to nil, let's just quickly do a fmt.PrintLn for us sowe can keep that error.Remember, this is not a permanent solution.And you go ahead, you can just copy and paste it just to save yourself some time.The HTTP error message from above.Don't forget the return.And then we wanna kind of remind the caller, or tell the caller,hey, we accepted your request.So what we can do here here is w header.We're going to set a field.I'm gonna type Content-Type like so,,application/json.And at the end, we can do json.NewEncoder, okay?So new encoder returns a new encoder that writes to w, which is our response writer.And here we can pass in w,and we're gonna encode what we want, which is the created workout.So this pattern here is a pretty powerful pattern that allows usto have more flexibility with different quote unquote, layers of our application.Here we're demonstrating the API layer to our database layer, butyou can imagine this goes beyond the scope of those two preliminary things.You can have multiple different layers, especially if you have specific packagesthat are doing microservices and they have a struct and they have function calls.You can kind of mess around with how you handle andorchestrate the different handlers across your application.
6.2 Testing CreateWorkout Endpoint with cURL
03:49:31 - 03:55:26
So we are missing one more thing andthat's because we have declared the workout store in the handler andour constructor is expecting this workout store butwe haven't actually called the workout handler with the new work out store.So if we go back to our app.go you can see here our lovely compile is alreadyyelling at us, which is great.And here we're gonna do declare our workout store.It's going to be store.NewPostgresWorkoutStore, andit expects one argument, which is our database, we can pass in our PGDB.And then to finalize the loop, we can go into the workout handler andpass in that workout store.So with all that kinda hooked up, I think it's a good time to try out if it works.So what we can do is if you go to a different terminal,go ahead and do run main.go.>> Melkey: Let's see, I almost forgot to turn my database.So if you go, docker, make sure the database's running, docker compose up.Okay, so yeah, make sure you have your database running.That was an example of our application panicking because our database connectionwasn't working.Now if we do go run main.go, if this doesn't work,I'll be very sad, but it does.All right, so we have our database connected, we're back and running.If you open up a business at fourth terminal, all right?This is where we're gonna curl a request.Now, as at the beginning you can go ahead and use any sort of API cutlery runner,post man, post woman, Bruno, these are all viable options, I use curl.Now, curl is great,however typing all along takes quite a bit of time, it looks messy.I have this file called post_notes.txt.Now, typically, I don't like doing this, I don't like how people just,here's some code, bring it in.I'm making the exception here cuz they're just pro requests with JSON bodies.Now, I just wanna quickly explain how these are set out.There's this little number here at the beginning, 1.5, andthen the actual JSON request here, okay?And you can see the following is 1.6, and if you keep scrolling down,there's 3.1, 3.2.These are related to the current submodule that we are working on.So right now we are on submodule 1.5.So when you go back, what we're doing here, and I'll add this to the commitmessage, 1.5 matches the 1.5 co request that we're creating here.We have our Go server running, we have our Davis connection.And then in the fourth terminal, go ahead and connect via PSQL, so I use PSQL.We can do use Postgres, the host is local host, port 5432.Remember, if you are doing this on a different from port,not 5432, make sure that is declared here, okay?And here now I can actually access the database,I can do slash DT to see all of the schemas we have through Goose migration.You can check, select all from workouts, this should be empty as it is, butwe can see the schema definition here.>> Melkey: So now with all that setup, let's go ahead and copy the very firstcurl command from the postnotes.txt right here, so that should be under 1.5.And if we go into, I guess this would be a fifth terminal andwe paste it, which should see the response in JSON, okay?So now we have essentially created a workout with the body of title,discription duration minutes, calories burned, andentries, the cool part here is entries is a list of workout entries,each with the individual exercise name, such as squats and bench press.And you can add on to this, there's no limit.This could be empty if you want, well, no, it has to have at least one workout entry,but this could be as large as we want it to.And the expected response is responding work to createa workout from our handler up here, okay?And if we kind of go back to PSQL, and I just ran the command,select all from workouts before running this command, this was empty,if I run this now, I now have an actual entry into my database.You can see here morning strength training, description, full body strengthtraining session, duration 60 minutes, I burned 500 calories.And the created ad andthe updated ad is the time at which this was inserted into our database.And we can even take this one step further, right?Because we have workout entries, if we do select allfrom workout_entries, we can see here we do in factsee the squat and the bench entries for that workout.You can see in the second column here that the worker ID is one for both of theseworker entries, which matches the workout ID from the previous table.Does anyone have any questions, anyone kind of seeing any errors,is it working for everyone?>> Speaker 2: Michael in chat says he's getting an error,column exercise name of relation workout entries does not exist.>> Melkey: That error is in the SQL under migrations work on entries,they don't have the exercise name column here.So make sure you have double-checked the repo I pushed,make sure your SQL tables are correct.If you ran your migration with an incorrect workout schema oryou missed a field, what I recommend at this point is just new to database andrerun it, or you can skip ahead and figure out how to do the migration call.
6.3 Getting Workouts By ID
03:55:27 - 04:05:25
>> Melkey: Okay, good stuff, so now we're able to create workouts, andwe're able to have the correct tooling to validate that something's inserted,we can look at any error messages, and we can debug them as we see.So the next part we're gonna do is do the rest of the handlers, wo we wanna getthe work ID, update the work ID, and eventually delete them as well, okay?So we're gonna work back into the workout store, sothis file here, the one that has our interface and our struck.And the first thing we're going to do, and as always,if you have an interface in your application code,what I would always recommend is add the function definition here first.You can see here we have our Create and GetWorkout,let's add a new one for UpdateWorkout, like so.UpdateWorkout is gonna take an argument of a pointer to a Workout,and it's going to return an error.So that's simply the function definition for our workout store interface, okay?And I think an appropriate part for us to pick up where we left off is finishing upthe GetWorkoutByID, cuz right now it's just simply a scaffold of the function.So we're gonna start right here.Now, for this one, we're gonna follow the same pattern, solet's go ahead and create our own query, like so, okay?We're gonna SELECT id, title,description, duration_minute, andthe calories_burned from our workout table, okay?So FROM workouts, and we wanna make sure WHERE id equalsthe one value we're gonna pass in, right?If we're gonna have a bunch of workouts in the table, we want to retrieve the one byits identifiable ID, which in our case is simply just ID, okay?Once you have that query ready, we can then declare the error here as pg.db,and here, we're actually gonna do query row.So this executes a query that's expected to return at most one row, okay?So different functionalities, we have query row,we have query execute a bunch of different things that we can use from the driver andthe native SQL package and go.So it depends on what your use case is, right?But here, we're gonna pass in the query andthen the one argument our query expects, which is id, all right?And then here, we're gonna scan all those fields that we're selecting intoits appropriate fields, quick reminder, these have to be addresses, right?These have to be pointers that we're gonna scan this into the pointer of our workout.So what we can do here is reference the address of our workout,we can put in the order they come in, so it's ID,then it's workout.Title, Description, description,DurationMinutes, >> Melkey: Andthe last one is calories burned, like so.So all you have to do is make sure you match the appropriate fields from ourworkout struct to the fields we're selecting from the query above.Now, we have to appropriately check our error, sowe're gonna check two fields here, okay?So the column one is, if our error does not equal to nil,we're gonna return nil and the error, we've seen this before.However, there is a chance that someone may be querying a workout that justdoesn't exist.Which that's not an error that is simply a behavior of what may happen witha relational database, right?The Postgres is gonna error out, if you try to [INAUDIBLE] something that doesn'texist, it's going to return, this thing doesn't exist.So we have to account for that, and SQL,the native package in go gives us that tool to help do that.So we can do if error and we can check does it equal to sql error, NoRows, okay?So this is returned by Row scan when DBquery row doesn't return a row, all right?So in this case, what we're going to do is just simply return nil and nil.>> Speaker 2: This data structure just simply, oran interface that just returns nothing.>> Melkey: Which one of this?>> Speaker 2: The sql.ErrNoRows?>> Melkey: Yep, if you go into it,it's actually a variable that's created from an errors.New.So the native errors package, it just creates this variable that we can use.>> Melkey: So like you can literally replace this with errors.New andreturn that if you want, but it's gonna satisfy the error constraint,that's why we can put it as an error.>> Speaker 3: It always end up returning early in this case though,if you have error not equal to nil before that, or do I misunderstand?>> Melkey: Let's see, if error is not equal to nil, return nil error otherwiseit will always return, yeah, you're right actually, these should be swapped.Yeah, so first we check if it's empty or if it matches an ErrNoRows,then it's gonna nil, and then we check if there's an error.Good, catch, cool, so at this point, right here,we're able to retrieve the entire workout, butwe still have to retrieve all the entries.Remember, like a one too many relationship.So if we only really cared about those high level items on our workout,we can consider this done, but we need to go ahead andquery the individual entries that belong to this workout.So to do this, I'm gonna quickly make a comment, let's get the entries.Okay, and to get the entries, it's gonna be a pretty interestingapproach here, but it always starts with our entryQuery.>> Melkey: Okay, here we're gonna select all the fields thatwe care from our our entries, so id exercise_name,sets, reps, duration_seconds, weight, notes andthen the last field is order_index like so, FROM workout_entries.The entries table where the workout_id equalsto the [INAUDIBLE] we're going to pass in.Okay, I'm gonna ORDER BY the order index sowe get adhere to the order they are represented in our database.Now since this is a one-to-many relationship, this query can respondwith multiple different results from the workout entries table.So we have to handle this in a bit different way than the query row above, sohow do we do this?We need to clear rows and error as pg.db, or we simply just write Query,and here we're gonna pass in our entryQuery andthe one argument this query expects, which is just id, okay?We're gonna check the error, so if error does not equal to nil,I'm gonna return nil and the error.>> Melkey: Otherwise, before we move on, we want to defer rows.close, okay?So we make sure that we close any lingering connections to the database andany lingering return results from this query here.Again, gonna prepend it with our defer function keyword, okay?So now, we have these rows, we're gonna iterate through each single one,every result could be one, could be a ton, right?We don't know, but we really don't care.So what we can do is for rows.Next, right?So it's gonna iterate through the next result of our rows.Here, we're gonna create within the function of this for loop,we're gonna do var entry is gonna be of type WorkoutEntry like so.And here we're gonna do err is going to be rows.Scan.We can potentially make this a little bit easier to read instead of makingit one giant line.I can stack them here, it just because the screen has to be a little bit zoomed in.So here we can do entry.ID,I'm gonna scan all this into the appropriate fields.We can do entry.ExerciseName, entry.Sets>> Melkey: entry.DurationSeconds.>> Melkey: Wait, notes and then entry.OrderIndex.>> Melkey: Okay, so your scan should have ID, exercise name, sets,reps, duration seconds, wait notes and the order index.So, individual going through every return result anda passing those results into its individual entry workout entry type.Here we're gonna check if there is any error, soif error does not equal to nil, we can simply return nil and the error.And in the last part, we can do workout.Entries andwe can use the fact that entries is a slice to append to it.So we can do workout.Entries equal append, to pass in the existing slice,which is the workout dot entries, and then we can pass in the newest entry, like so.So that's gonna actually be the completion of the get workout by ID function
6.4 Updating Workouts
04:05:26 - 04:17:06
>> Melkey: I figured since we're already in the workout store,let's just create the update workout function as well, andthen we can scaffold both of those into the workout handler, okay?So right underneath the get workout by ID function, we just created,we're gonna create our news function, func pg is gonna be PostgresWorkoutStore,and this can be called UpdateWorkout, like so.It's gonna take one argument, which gonna be a workout, which can be a pointerto our workout, and it's gonna return our error or a error, which could be nil.Now, updating a workout requires us to go into two different tables,and if we update one part of the workout, something happens.We don't want that, we wanna adhere to the asset principle and databases.So because of that, we're gonna again create our transaction here,like we did in the create workout.So here, let's go ahead and create our transaction variable and an error.We can say pg.db and we can say Begin like so.We can quickly check for the error if our error does not equal to nil,we can just return that error.And like we did above, we can just defer any rollbacks, sotransaction not Rollback like so.All right, so now once that is defined, we can go ahead andstart creating the queries for updating our workout.So here I'm gonna just create the Query here.>> Melkey: Okay, and this is gonna be fairly simple,we're gonna do update the workouts table.I'm gonna Set the title to value 1,description to value 2,duration_minutes to value 3,and calories burned to value 4, like so.Where the id is going to be value 5, okay?So now this query when we call it expects five variables that we will parse in,okay?And luckily forus these all exist into the argument we parsed in which is the workout, okay?And just like we did before, we are going to now call this query,we're gonna first create a results variable and error.And this is gonna be tx.Exec, like so, parse in the query andthen the five functions it expects in the order they appear.So workout.Title, workout.Description, workout.DurationMinutes.>> Melkey: Workout.CaloriesBurned, okay?And the last one which needs to forget, workout.ID.With that, always check the error, so if error does not equal to nil,let's go ahead and just return that error.And now what we wanna do, if there's no error, we would like to know,did this work?Cuz again, you could update something technically that doesn't exist.It's not gonna error out, but the query can just say, yeah, nothing was updated.So we wanna know how many rows were affected through this operation.It can do something like rows affected, okay?Err, is going to be result dot this nifty little function called RowsAffected,which returns the number of rows affected by update, insert, or delete, okay?Little comment there, not every database or driving may support this, Postgres andPGX does indeed support this.>> Melkey: All right, and again, we can just check some errors.So if err does not equal to nil, let's go ahead and return that err.And then we can check if rowsAffected is zero, so if rowsAffected is zero like sowe can just return our sql that err, no rows like we saw above.>> Melkey: So this point, just like we did with the with the get, we have onlycompleted that first portion, the workout part of our struck, which is a high level.But now we have to do the entries, okay?So with entries, it can get complicated, andthere's two ways someone can handle this.So you can actually, from the requester,get the request of the ID of the individual entry you wanna update,iterate through it, find the ID and update it like so.Or you can do what I'm gonna implement, which is a full-on patch update.We're gonna actually delete all the worker entries as a whole andthen we're gonna reinsert the workout entries, okay?So this seems like a bit of a small potentially, but what we're going to do isin the caller, we're gonna first get the workouts which we saw earlier.We're gonna have all the workout entries, and then we're gonna match the requestfrom our client to see if there's any differences for fields they wanna update.And I'm gonna send all of that into this function here.Okay, and we can, you can do both, both are fairly effective,this one is just easier to implement.This one's easier to implement, but potentially more at fault for things togo wrong, whereas the other solution, where you iterate through work at entries,parse them by ID, make that ID, something that you request from your client.Maybe it's a little bit more complicated, but a little bit more secure.So I'll leave it up to you if you wanna change it up, butwe'll have a working solution here with this approach.So we can start this by just declaring a new error andusing the transaction Exec one more time.I'm gonna build this query in line, so use the backticks.We're gonna simply just write DELETE FROM workout_entriesWHERE workout_id equals the first value, andthat value can pass in right away with workout.ID.We're getting yelled at that no new variables exist on the left side.So if you're getting this, just remove this local of the walrus operator.All right, let's check that err,if err does not equal to nil, you just simply return the err.Otherwise, we can iterate through the workout entries that we get from ourclient call, and then insert those individually into our database.So here, we can do entry in rangeworkout.Entries, like so,we create our new query.And this here is gonna be INSERT INTO workout_entries,make sure you spell that right, I keep typing entires.We can type in all the fields we wanna insert, sowe can do workout_id, exercise_name, sets, reps.The duration in seconds, notes,and order index, like so.And again, should be eight values that we're inserting, so we can do VALUES.>> Melkey: 3, 4, 5, 6, 7, 8.And for some people maybe asking why is it like that money symbol?That's just Postgres native, that's how we do it in Postgres,how you pass variables via Postgres drivers.I think in no SQL, it's different, I forget what it is in otherdatabase drivers, but I know in Postgres, it is the money symbol.And I realize I've a typo here, somake sure that this is VALUES, oops, like so.>> Speaker 2: Are you missing a item and the insert query?>> Melkey: Let's see, Worker ID, 1, 2, 3, 4, 5, 6, 7, what am I missing?>> Speaker 2: Wait, I think.>> Melkey: Yeah, good catch.>> Melkey: So, duration, seconds, weight, notes, order, index, yep.And so, now that we have the query defined,we can then execute this with our tx.Exec.Let's put in query and in the order at which these variables come in.So when it was noted that weight was missing,I specifically put it after duration seconds, andI'm gonna adhere to that when I pass that variable into the order here.So I'm just gonna open this up just to make it a little bit easier to read, okay?I'm gonna put workout.ID, andthen, entry.ExerciseName,entry.Sets, entry.Reps, okay?Entry.DurationSeconds, entry.Weight, entry.Note.>> Melkey: And the last one is entry.OrderIndex.Okay, we have to just check that err, so if err does not equal to nil,let's just return the err.And then the last compiler error that we should be getting is that we're notreturning anything, but we can just simply return tx.Commit.>> Speaker 3: I guess, to recap, instead of finding specifically, like two pointthe transaction and updating just that one, just get rid of it.>> Melkey: Yeah, this is like a full patch update, sowe're just eliminating all the entries and we're gonna reinsert them.And as is, this puts more emphasis on the API layer.So we'll see once we hook this up into our workout handler,we actually do a get workout call to get everything.And then we match if there's any updates to the entries from our caller's payload,and then we call this function to insert them.>> Speaker 4: One quick question on the tx.Exec call where you delete, I didn'treally understand why we needed to get rid of the colon there to get rid of that err?>> Melkey: So this is a compiler err and what this is saying so you may be kind ofwondering why this is erroring out like let's say here it's not right like, right?Above, so if I were to just remove result a bunch of things are gonna go red,just heads up.If we do this and I ignore the first response,we're gonna get the same err here, no new variables on the left side.And the reason for that is because the compiler ignores the first response,which is this result, and only cares about err.But since we've already declared err way above here for the first time,the compiler doesn't allow us to redeclare a new variable with the same name.We can rewrite err, right?Like so, so now it's fine, but we can declare a new variable,which is what this shorthand form syntax does, it declares new variables for us.So if we kinda go all the way back, we have result.It's fine here, but at the bottom here,we don't really care about the result from this particular delete query,which is why we can remove the short form colon operator here andjust rewrite what that error is, or reassign it, the value from tx.Exec.>> Speaker 4: Got, so because you have the result there, it's assigning result andkind of ignoring the fact that error was already.>> Melkey: Exactly because result is in fact new,it's going to give us the brand new variable result and then reassign err.
6.5 Handlers for Getting & Updating Workouts
04:17:07 - 04:33:34
>> Melkey: All right, very nice.So now we have to get workout andthe update workout methods only in our data store.Let's go all the way up to the workout handler and fix these up, sothat we can actually call them, query them and test them out.Let's go into the workout handler above.So just a quick reminder we already have HandleCreateWorkout function, working.So now we're gonna work in the HandleGetWorkoutByID.This can be fairly quick, not quick, butsimple integration here.So at the bottom here, after we check the last error for the workoutID,what we can do is workout error is gonna be our workout handler,the workoutStore and the GetWorkoutByID function.We can pass in the workoutID.>> Melkey: As per usual, let's check the error, so if error does not equal to nil,we're gonna do a format print line error.>> Melkey: Bear with me, it's not permanent.We will fix this in a couple of minutes.We'll do the http.Error function, pass in the response writer like so.We can say failed to read the workout or fail to retrieve the workout.And here we can do http.StatusNotFound.>> Melkey: So we can actually just say method to read the workout because theyfail to fetch the work, I think it's a bit more explicit to what's happening, okay?Let's not forget the return at the end there, okay?And at this point, we are assuming we're able to retrieve the workout correctly.So then what we can do is w.Header.Set, Content=Type>> Melkey: Application/json.We can do w.WriteHeader over here,when I give it the status of (http.StatusOK), like so.And right below, we can do json.NewEncoder,pass in the response writer I'm gonna encode the workout like so.Let's go ahead and just create the update method now as well.At the bottom, let's get some room for us here, like so.Create func wh for our pointer to our WorkoutHandler.I'm gonna call HandleUpdateWorkoutByID, like so.It's gonna take our w http.ResponseWriter andthe body of http.Request or the pointer, excuse me.All right, and here we have to parse that ID as well.Since we already have that logic written and this will be its own function,we can do is simply just go up here and let's go ahead and link this much code.Instead of rewriting it from scratch, go ahead and copy andpaste this from the GetWorkoutByID function, andjust paste it in the first body, in the first line for the HandleWorkoutByID.Okay, I'm gonna use this workoutID to first fetch and get the workout.So here we can do existingWorkout error is going to be our workoutHandler,the workoutStore, GetWorkoutByID, andhe passed in the workoutID that we just extracted from our query using chi.Check the error, so if our error does not equal to nil,down here, we can do http.Error.W failed to fetch workout http.Status youdo InternalServerError like so, and then we can return.And here we wanna check if existing workout is nil cuz we can do a get requestand see if it's empty or not.So here if existing workout is in fact nil after the error check,you just do http.NotFound for right now, w r and then return.Okay, so at this point, we can assume,we are able to find existing workout.>> Melkey: Okay, now what we're going to do right now is create a new structwhich is going to act as the request from our Client struck.So you remember, when we create a new workout,we are basically decoding that JSON into the struct.We need to do the same for update requests, okay?But the thing is, we don't wanna blindly trust our client.I'm sure there's gonna be some client side validation, and that's important.But we can also do some server side validation as well.Is it overkill?I don't think so, I think it's probably good to trust butvalidate at the same time.And so with that kind of thinking, we're gonna create this struck, not anonymous.It's gonna live within the scope of this function, andyou can make it live outside the scope.You can globally declare it in the package, that's fine.But here, this is going to act as that preliminary location forus to decode that JSON.We can then validate that are the fields correct,is it adhering to the password length that we want etc, etc.And then we can replace the values in our actual existing workout with thosevalues from our client and then call the update workout method.So I'll show you how that looks,you can create a new variable called updateWorkoutRequest.This is gonna be struck, and this struck is basically going to have the same fieldsour workout does, with a slight difference.We can do title and this time, instead of being a string,this is gonna be a pointer to a string like so.Same json tags, title, all right, and we'll follow up with the rest of them.Description is going to be also a pointer to a string.We can put description like so,okay, we can have DurationMinutes.This is gonna be a pointer to an int.>> Melkey: json duration_minutes.We're gonna have calories_burned, >> Melkey: Oops.>> Melkey: Like so, this would be pointer to int.>> Melkey: Okay, and the last one are entries, right?Because we know entries is a slice, the native default type forslice is already nil.So we can do store.WorkoutEntry.Okay, we can do our json tag as just entries, like so.With that now declared,we can use the same json logic we had earlier of the NewDecoder.Let's grab it from our r.Body, and what we're going todecode is in the updateWorkoutRequest, like so.Let's check that error.So if our error does not equal to nil,we can just do http.Error pass in the response writer.And then we can just simply write the actual error message that weare extracting from the decoder like so.We can do http something like StatusBadRequest.>> Melkey: And make sure we return.>> Melkey: So now that we have this updateWorkerRequest, andlet's say we successfully decoded it, the question is, why are these pointers?And the reason for that is this allows us to now check if thosevalues are truly nil or if they intend to be empty.Let's say someone goes back and updates the workout, and they said,you know what, I don't want a description on this field, and they leave it empty,like an empty string.Which we found out is the default or zero value of strings for Go.Do we want to treat that as if it's a non existing value andnot update that work with entry?Or do we think that our user is actually trying to update this forma description to be empty.So to do that successfully, we can check with a nil pointer.We can check if that value is actually nil or not from our client,because if they don't send anything from our client,there's nothing gonna be there, and a nil is not the same thing as an empty string.So this updateWorkoutRequest variable that we have,we could do something a little bit repetitive, but I think it's worth it.We can check if updateWorkoutRequest.Title, andwe can do this for every field does not equal to nil, right?What we can then do is existingWorkout.Title,reminder, existingWorkout is the worker we treat just a few lines above.We could set this equal to the def reference value ofupdateWorkerRequest.Title, like so.Cool, so just a little bit more service-side validation on what we'regetting and expecting from our client calls.>> Melkey: Okay, and we can do this for all those fields, soyou can go ahead and copy andpaste this for description, duration, minutes, calories burned, and entries.You can do UpdateWorkerRequest instead of .Title, we can do description.If you are copying, make sure you are careful with fixing the field names.>> Melkey: So I got DurationMinutes, next I'm gonna do CaloriesBurned.>> Melkey: All right.>> Melkey: And the last one is Entries.>> Melkey: Yeah.>> Speaker 2: Could you explain why wedon't need the pointer on the Entries again?>> Melkey: Yeah, absolutely, so string and ints, the zero value forthose is either an empty string or a zero, right,with a slice, the zero or different value is nil.So the reason we're even using pointers like on relative line 29 up for title,description, duration, is because the zero value for a pointer is nil.And so that gives us that ability to check,does this actually exist or does it not exist?And which goes back to the example,maybe someone actually wants to send zero, right?If they do, okay, cool, we can process that but if we don't have a way to fullycheck the integrity of the request that we may accidentally take a zero value by Goand replace it to be something that it really shouldn't be.So this nil check gives us more of that,not authenticity, but more of that confidence to make sure that weare processing the right request from our caller.Here, we can just do error.We can do workout handler is workoutStore.We can click UpdateWorkout.You can pass in that new, fairly new, but we can say improved existing workout.You can check if our error does not equal to nil.We can just print the error for ourselves.We can just do format.Println and say, update workout errorto be more explicit in case some people do get errors here.So we're trying this out.We can do error w and we can also say,failed to update the workout.We can put http.InternalServerError, we can return.And the last little bit is running back to our client.So w.Header we can set Content-Type.>> Melkey: Application/json, like so, we can do right our header, so w.Write.>> Melkey: There you go, right.Here we can do http.StatusOK.And then we can just say json.NewEncoder, pass in our response writer,and then we can encode the existing workout like so.So we just wrapped up writing our update handler, and forthat, we just created the functions in our Data Store forcreating, reading and updating the workouts.So now we're gonna test these out.There's just one thing we have to do,which is to route one of the new functions that update handler into our routes.So we'll go here, so right underneath the workouts,we can do an r.Put, okay?And here we'll put passed in/workouts, andthen the slug, which is just the curly brackets, id.And here it will be the function name.So we app.WorkoutHandler and then HandleUpdateWorkoutByID.Again, we're not calling these functions cuz functions are pass as first classcitizens in Go.So we could just pass them like so.So with all that,we can finally validate if those functions we created all work accordingly.So go to your running go server, you can go ahead and nuke it and run it back up.Awesome, if you have any errors, I'll show up right now.Any compiler errors or not compilers but any errors from connected to database,things like that.Those will show up right now.All right, so I'm gonna make sure I have my Docker compose running.I have PSQL still running, sothat's allows you to check what's going on my database.And I have this last terminal which I can use to curl.And again, you can use whatever you want.But if you are following along, you can go into that post_notes section here,and the next sub section should be 1.6.Now this 1.6 request body, it's going to make the put function call to our address,http.localhost8082, to workouts to the one workout we have in our database right now.And here we're gonna be updating it, so you can see we have tile description,duration, calories, burn entries.And one thing to note, we're actually adding a third entry here,the plank, right?So we had previous squats, and I think it was push ups.Now we're modifying this to dead lifts, Pull-Ups, andadding a third ring called plank.And if you want to validate this,we can go again into select all from workout_entries in PSQL andsee that the two entries we have for our workout are just squats and bench.So ideally, once we call this function,we should see a bunch of this stuff be updated.If not, we're in trouble with the debug.So go ahead and copy all this down and in your empty terminal or again,whatever UI you want to run, paste it, you click Enter.You should now see this very, very appealing looking JSON square blob thing.
6.6 Deleting Workouts
04:33:35 - 04:42:53
>> Melkey: So, if we look at a PSQL now, we can validate this.So, before we saw the two previous entries, if we do this,now we see deadlifts, pull-up, plank with the modification that we see.We have the workout id all tying back into the workout that we have, again,one too many relationship.So, I think it's fair to say that we are able to successfully update a workout,we're also able to create a workout,we can check the workout as well if they exist.So back here, whatever you use,you can just simply do curlhttp://localhost8080/workouts/1.>> Melkey: There you go.So we can retrieve, we can create, we can update, it's looking pretty good.The few things that are blatantly obvious that we're gonna improve, and beforewe get to those, we need to add the last kind of Horseman of crud, which is delete.And that shouldn't take us too long, butI do believe that now that kind of the way to do it is fairly obvious, right?We start with a database layer, create it there,hook it up to the API workout handler, and then we route it.And we can repeat this for any kind of path we want, right?Any path that is specifically going to be interacting with the database.If there's no interaction with the database,you can skip the database layer altogether.But since we're not gonna do that, let's go back to the workoutstore.go, andquestion to anyone, what is the first thing we actually need to update here?>> Speaker 2: Interface?>> Melkey: Yes, exactly, we need to update the interface.Cuz if we don't, we're gonna get an error saying that we cannot pass the workoutstore as something in our workout handler.So here in update workout, we're gonna create a new method called DeleteWorkout.DeleteWorkout is gonna take one argument, which can be id of type int64 andit's gonna respond with an error, all right?So now let's go all the way down, make some room for yourself andin here we should probably know the drill by now.Let's go ahead and make our func, it's gonna be (pg *PostgresWorkoutStore).Let's call this DeleteWorkout, give it that argument, int id 64,make sure it responds with the error like so.>> Melkey: Let's make that query, it's gonna be pretty easy.Delete from workouts, where id equals the first value we are going to pass in andthe only value we're going to pass in.>> Melkey: Following the same kind of blueprint we laid out,we can just do result, and error is gonna be pg.db, we can execute that query,pass in that query, and the one argument which is id.>> Melkey: And then everyone's favorite checking for error.So if error does not equal to nil, we first check if it's nil ornot, we can then return whatever that error is, okay?You don't need to necessarily do this, but I'm going to again, just to be explicit.We can do rowsAffected as result.RowsAffected, check the error here.So, if error also does not equal to nil, maybe we can return nil.Otherwise, if rows affected is 0, we can return sql.ErrNoRows like so,everything works correctly, we can just return nil.>> Speaker 3: Does that need to be flipped again?If you have error not equal to nil, andthen actually, never mind.>> Melkey: Let's read out, so we first check if it's not nails.It's not that it has to be flipped, this has to be error.>> Speaker 4: You ever set up some sort of hockey orshortcut to do if error does not equal.>> Melkey: No.>> Speaker 4: You typing it?>> Melkey: I'm a masochist, I love typing it at this point.There's been attempts to add packages that do it for you, doing all these things,that's just been rejected by the Go community, like outright rejected.Very nice, so now proud to announce we have all of the functions forcrud in our workout store, creating, reading, updating, and deleting.And we should know that now we can go head on, back up to a workout handler like so.Let's go all the way down, give us some room, andhere we just need to create that delete function.And I actually am gonna challenge everyone here,I'm gonna type it out, see if you can do it yourself.If you can't, that's not a big deal at all, we can make this a mini exercise.I just don't wanna pause in the action and then kinda continue,so feel free to just look and copy what I write or try it out yourself.Maybe the way you do it will be cleaner and better, right?So, let's do this together,I won't be talking too much, >> Melkey: Andyou don't have to worry about the naming is just the only part is if you do name itsomething different than handle, delete, workup by id, like the one I have here.When you add it back to your routes, make sure reflects the function name,whatever you choose to use.>> Melkey: Okay.>> Melkey: I'm gonna go ahead and grab this.>> Melkey: I'm gonna pull that worker id, cuz we need it.And then here can do something like this, the workoutStore andthe DeleteWorkout method and actually pass in that workoutID>> Melkey: All right, soI check if that error is going to be a sql.ErrNoRows.>> Melkey: Okay, then we check with the error exists or not, and then here wecan just simply do w.WriteHeader, cuz we don't want to respond with any.You can add a particular message if you want in your JSON,if you want to do successful, delete it or not, feel free to do that.I'm gonna do (http.StatusNoContent).>> Melkey: Like so.So let's go back to the route, we can check if your function works,again, hopefully you try to maybe do something yourself.If you just felt you wanted to copy and learn it, totally fine, right?Whatever is easy for you, so here we can do workout and then pass in that slug id.And in here we'll pass in app.workoutHandler and then handle,delete, get workout by ID as a first-class citizen.All right, moment of truth, let's bring down the server and go run main.go, okay?And here in this particular manual test, we wanna test for two things, well, three.One, does it work, two, is it deleting the thing it should be deleting, and three,is it deleting the workout entries as well, all right?So, if we look back in our psql, we have one workout, right?We just have the workout id, belongs to 1, sothe slug that we're gonna pass into our curl should be /1.You can do curl -X DELETE, which is the method,the HTTP method, localhost8080/workouts/1,okay?And if you do -v verbose, it will give you the HTTP status in mind,I'm not responding with any JSON.So, there's no true indicator if it was deleted or not, you can modify that.I use an HP header or status called stud.If you run this, like so, and then if we go back and run the exact same query,select all from worker entries, it should be empty.And if we do select all from workouts, it's empty as well.So, we have now fully gone through the implementation of a CRUD app,we are able to create, read, update, and delete, and I think that's pretty cool.
6.7 JSON Response Writer Refactor
04:42:54 - 04:49:04
>> Melkey: So at this point in time, we can actually go to the next section.But it won't be very good of me to do that because there's lots of smelly thingshappening in a code base, okay.There's lots of DRI, there's lots of just nastiness that I want to address nowthat we have this opportunity to kind of go in between this section andthe following one which is going to be testing.Now, this particular sub module section is going to be too long, butwhat it will do is it will introduce a new utils package for us to use, all right.And this utils package will do a few things for us.If you noticed, if you go back, the JSON getting back looks very ugly.The JSON get back is just it's not organized, it doesn't look like pure JSON.It's no indents, it looks very not nice.And then another thing is, in all of our handlers,we are repeating the read ID parameter function over three times now.And I'm actually a person who isn't super particular DRI,if you have to do it, go ahead and do it.But in this case, it makes no sense, because it's just updated to update inthree different places now, which is kind of just annoying.So what we're gonna do now is gonna create a utils function.We're gonna address writing JSON in an easier way, in much more maintainable way.I'm gonna add a read ID param function,I'm gonna clean up the handler specifications that we have right now.So in the internal folder, let's go ahead andmake a new folder called utils, and then within utils,go ahead and make a new file called utils.go, okay.I'm gonna call this package utils, okay.And the first thing we're going to create is func writeJSON, like so.This writeJSON is gonna take a few arguments, first,it's gonna be the writer.So it's gonna be HTTP response writer, like so.It's gonna take a status, which can be a type int and a data type.Now, it's gonna be a really cool thing that we're gonna realize how we cannavigate through different types in Go, buthere we're gonna introduce a new type called Envelope, okay?And this Envelope is going to be a map which takesa string as key and then an interface as a value.It's particularly a naked interface or empty interface.Now you may be asking, why and what does this mean?Well, the empty interface is goes way of basically having the any type.And go does have the actual any type, I believe now,I think this was introduced later on in Go, call it for what it is.I'm gonna use just the interface type,I think my editor actually also recommends to use any sometimes.But I'm gonna use just this empty interface, and then here,data is gonna be of type, envelope, like so.And so why does this matter?Well, now for Ray JSON, we can simply give it data which is going to be a map,which is a type envelope with, let's say the string says error, andthen we can also pass it the error message or the actual error type, or on successes.We can say, this is your workout andpass it the workout struct for successful creations.So let's see how that looks, so here we're gonna just do some variable js,okay, I'm going to say json.MarshalIndent.I'm gonna pass in data, an empty string here, andthen two tabs, or just one tab.The tabbing means how much you wanna tab your JSON fields, okay.If error does not equal to nil, we can go ahead and return an error.And that just reminds me,make sure your right JSON is returning an error type like so.>> Melkey: Okay.We wanna add new lines to the JSON, so we can do append js, andwe can do single quotes, forward slash and to break the lines.>> Melkey: And then here we can just do W header, we'll set content dash,type, application, slash JSON, like so,W dot right header can do the status that we bring in.So again, status is an int,W.rightjs, like so.And then we can return, no.And while we're here, let's go ahead andalso create the func read ID param function.So this is gonna take the pointer to HTTP request likeso-and-so, return an int 64 and an error.And here we'll do ID param is going to be chi.URLParam,r,please slug we're extracting is ID.If ID param is empty, we can simply do return,just put any default value as zero and put errors.new.We're gonna create our own error type here,we can just say invalid ID parameter.All right, then we can transform this id param into a base 10 int 64 type,because right now it is a string.So we can do string conversion, parse int we can pass it ID param,the base 10 into 64 check the error.If error does not equal to nil, we can simply just again return zero anddo errors.new invalid ID parameter type.>> Melkey: And at the end here is return ID and no.
6.8 Logging & JSON Error Responses
04:49:05 - 05:04:09
>> Melkey: We're gonna do one more thing.You know those annoying format print line errors I've been asking you guys to put?Those are not great.That's very, very bad error handling.It works when it has to, butwe can make our jobs of error debugging a little bit nicer and easier.So we can go back to our app.go, and when we're declaring the workout handler,we're gonna give it a new argument logger, okay?Right now it's gonna say too many arguments in the call to our constructor,don't worry about it.>> Melkey: And we're actually going to leverage our logger, the one wedeclared in the very first kind of submodule, to write error messages for us.So now, if we go back to our workout handler.Let me go all the way back up, this workout handler struck nolonger is just going to be accepting the workout store.Now add logger, which can be of type log.logger.>> Melkey: In our constructor method it's gonna take logger,it's gonna be that argument that we just passed in, log.logger.And then our actual return, we can put logger as logger, like so.So here comes the fun part, we'll be rewriting a lot of code.You can hate me, that's fine, I'll take it.But I want to show how we can really get something working,and then how we can improve on it.All right, so here we're gonna start with the HandleGetWorkupByID.Everything here, from paramsWorkoutID to the workoutID return we can delete.And here, what we're going to do insteadis define workoutID err as utils.ReadIDParam,I'm gonna pass it in r.Okay, so we're gonna use the utility function we have here,we can check the error.So if err does not equal to nil, we can go ahead andwrite our wh, our logger like so, I'm gonna leverage this.We're gonna do Printf, and now this print is gonna be for us.I'm gonna make it a little bit nice.I'm gonna do error, all right?We can do readIDParam, something like this,%v, and I put the error like so.And we can also leverage our new writeJSON function.So we can do utils.writeJSON(w can passan http status, so StatusBadRequest, okay?And then we can use utils.Envelope like so, andwe can just say error and then pass in the key invalidworkout id and make sure we return, okay?And so go ahead and copy those two lines, the logger line and the writeJSON line.And now, when we call or check errors, we can simply use that style,that blueprint, that schema, if you will, to handle our errors.So here, error, which can be getWorkoutByID.So that tells us exactly what the error is going to be, okay?Otherwise, instead of StatusBadRequest, http.StatusInternalServerError.>> Melkey: Okay, and in the envelope after error, we can just say internal servererror, because remember, this is gonna be for our client.Our client doesn't necessarily need to know what'shappening from our own back end.If our back end is breaking, that's on us to log and figure out.We don't need to send every error message back to the caller, especially users.>> Melkey: You can, of course, be more explicit and maybe provide them an errorcode that they can then go to customer support or something like that.But that kind of be outside the scope of what we're doing here, all right?And then we can just simply delete all this stuff from the get workout ID atthe bottom.We can, again, utilize our new writeJSON, cuz it's not just for handling errors,we can do utils.WriteJSON, pass in our w and then here we http.StatusOK.>> Melkey: We can use utils.Envelope, andhere we can see some of the cool things of that interface or any type.We can just put workout, and here just put workout like so.So it's a nice little flexible function that we have forjust handling JSON back to our client.Let's move on to the create workout.So again, I'm just gonna go ahead and copy that logger in the utils print.And right here, right underneath the decoder,we can go ahead and paste this like so.The first logger error could be ERROR: decodingCreateWorkout.Again, this is for us.And here we can say invalid request sent,and this is back to our callers.Let's go ahead and take this, put it down in underneath the created workout.So when we call our handler workout store and the create workout,here the error mesh would be CreateWorkout.And there's a bit of a pattern here.So the error message is followed by, typically,what is the function calling that workout, whatever is more flexible for you.There's this kind of pattern set, but nothing set in stone.I'd always recommend do what's most obvious for you.Here, we can do StatusInternalServerError, cuz if something goes down andI was creating it, which is back to our database layer, that's on us.So here we can just say "Failed to create workout".>> Melkey: All right, and then here instead of doing the header andthe encoder, what we can do is utils.writeJSON(w, http.StatusCreated).>> Melkey: Like so, can use utils.Envelope.Okay, we can do workout as the createdWorkout.Let's go ahead and finish up the update workout and then the delete workout.So in the handle update, we have, again, those params, sowe can just simply go back to handle workout right here.Let's go ahead and just delete all that and declare workoutID,okay, and error is going to be utils.ReadIDParam,pass in the pointer r, check the error.>> Melkey: All right, I'm gonna just go scroll back up where I already wrote this,so something like this.>> Melkey: Okay, and then when we fetch the workout, sowe can just rename to getWorkoutByID error.>> Melkey: You can make this StatusInternalServerError, okay?And in the envelope, we can do error and can do internal server error, okay?Now, again, you can feel free to modify those error message to whatever you want.There's lots of flexibility with the utils.WriteJSON utility function.If you wanna be more explicit to your caller, more explicit to yourself,feel free to do so.I'm just taking a bit of a liberty here.I'm just kind of using the internal server error as a catch-all statement.Is it the best user experience?We could probably debate that, butwe can explore different ways to make it better down the line.So we have a few more spots we need to handle our errors.So if we go into the decode here,you can see ERROR: decodingUpdateRequest.Instead of internal server error, this is is gonna be StatusBadRequest.>> Melkey: Okay, I'm gonna say invalid request payload like so.And then in updateWorkout, you can go ahead and say error updating the workout.This would be StatusInternalServerError once again.>> Melkey: Like so, and then we can remove these header types at the bottom here andagain leverage our utils.Envelope, but utils.WriteJSON.We'll say (w, http.StatusOK,utils.Envelope).>> Melkey: You can put workout, and here you can put the existingWorkout.So we can do the rest for delete as well.I'll leave that up to you because it's repeating the same thing.But this is just a way for us to handle our errors, and specifically our JSON.And I wanna demonstrate that, so we have the go server now fully running.If we go back to our post notes here, so we finished 1.6.There's this new post notes text section 1.8,and this is simply a summary of the co-request, sowe don't need to have them repeated, but I think it's just easier.So here I'm gonna copy this post.This is the same one for creating, right?And in here, all I want to demonstrate is how the JSON looks.So if I paste this and I click Enter,you can now see our returnJSON looks much nicer.It's not just this blob at the bottom andyou kind of looking like, what does this mean?What is this?I don't really understand this.It's much nicer for us to parse and release.You can see here's a request and here are the values.And actually noticing "id": 0, that is probably because we're not returnthe id from our entry, so we can modify that, or even remove it entirely.So we can go ahead and do that.So here, if we go to workout-store, andthis was in the Create method.>> Melkey: So here we're returning ID.>> Melkey: It's a bit odd, I'm not too sure why it's actually empty.>> Melkey: Returning id, let me just double-check.We'll explore that later.So the worker does, in fact, have the id.I'll debug why id here is 0.I'll make a quick fix for it.It's probably some typo going on, ormaybe I'm not having that field correctly in the actual entries.But the main point is that now our JSON is legible andwe can use this more accurately in the rest of our code.And we can even do something like a get now.So if you go back into the post_notes and then here.So we just curled and created a workout.If we just do a simple GET, I'm gonna go ahead and copy this and paste it.You can see we actually have the work that's working.Yes, so GET is actually responding with the appropriate ids,but to create isn't so.Gotta figure out why that is.But yeah, now we have much better JSON, much better area handling as well.

7.0 Testing Go Applications
38m 20s
7.1 Using a Testing Database
05:04:10 - 05:12:26
>> Melkey: So as we wrap up the core CRUD portions of the application.We can start moving on to a different aspect of Go entirely, andthat's gonna be testing.Now testing is a pretty wide topic.You obviously have unit tests, mock testing, integration testing,manual testing, beta environment testing.I mean, testing at itself, could be an entire course.And for this particular course, I want to incorporate testingtechniques I think are very valuable from a practical sense,but also valuable from a sense of what others might have to say.[COUGH] So I have this slide here,there is some great books by this really wonderful author, Thorsten Ball.And Thorsten has written some really good books,two in particular is writing a compiler in go and writing an interpreter in go.And in these two books, he actually goes with a different approach of teaching.He goes with test-driven development.So he actually writes test first and then the functions to couple it,which I think is very good.I personally don't adopt TDD all that much, I think a lot of times running testover and over and over again can become appetitive.But that's not to say that the style that Thorsten chose to write his books is wrongby any means, it's just different flavors for different people.And so what we're gonna do here is we wrote the code,we gonna couple it with some unit tests for our database, okay?And I have this video here, which I'm going to click, I'm not gonna play it.But in this video, this is Mitchell Hashimoto, actually.And Mitchell Hashimoto is the creator of Ghostty.And he is at GopherCon in 2017 talking about differenttesting parameters and different test fixtures in go.And one particular thing I wanted to highlight from this talk, I'll link it inthese slides so you can go ahead and watch it, is the notion of table-driven tests.And we're gonna be using table-driven tests.And the syntax here should look fairly familiar.Maybe there's some quirks here that if you're a first time go developer,you may be asking yourself, what does this mean?But the part I wanna highlight is the use of the anonymous struct here, right?We've talked about this when we were designing structs in the first place.And structs, especially anonymous structs, are very helpful anduseful when it comes to table-driven tests, okay?So we're gonna be adopting table-driven tests in our code base here.We're gonna be doing quite a bit of tests.I'm actually going to approach this in a systematic way.I'm gonna show you how to write a test.I'm not gonna show you how to write all the tests,just because it gets very repetitive.It's like over and over and over, the same thing, right?So I kinda wanna drill down the concept of, what it is to write a test,how we go about it, why I chose to do things I chose to do.And then you can feel free to accept it, use any kind of testing approaches youfeel that you're comfortable with, and we can move forward with that.So before we get started, there is one aspect I really want to break down, andthat's currently how our application looks like.And if you really, really look at it, it's just, essentially, two main files, right?Three things include main, and if we kind of ignore app and routes.We have our workout store function, which is directly writing to our database.We've confirmed it works, we have a database running, we know it works.And we also have this file here, which we know also works, because it's acceptingour request, it's able to handle them and this is our handler.So the test I'm going to first approach is gonna be focusing on the workout store,all right?And you may be thinking, okay, well, how can we truly test this?Or what functions can we write that will testthe integrity of the function we wrote here?And there's many different ways that we can approach this, andthe approach I'm going to use is actually going to be spinning up a test database.So we're gonna be spinning up another database that is going to be justspecifically used for testing.Maybe you're asking, well, what's the point if wehave our current database here, that is, the container_name: "workoutDB".And the way I look at this is, in production, I would assume most ofthe time you'll have a dedicated database running on some hosted sever.Whether it's AWS DynamoDB, whether you have a separate database on a provider,[COUGH] like Superbase or some like that.Those are different ways that you can kind of have a production level database.Here, this database that we see is simply like our beta local database, right?And it persists our data,we have the volume persisting that we can bring it back.We can tear it down, bring it back up, and the data will still be there.The reason why I wanna have a test database is this test database is going toonly exist to validate the integrity of our SQL.So we're actually going to be writing values into this database, we're gonna beretrieving them, and we'll be checking to see if they're correct or not.Is it storing the values it needs to store, is it retrieving the valuesit needs to retrieve, is it updating the values correctly?So here we're gonna actually have a test database,which we're gonna use only for this test case here for a data base layer.And this is just one approach, right?This is my personal opinion.With testing, I'm actually very opinionated,as much as I like to meme on tests, I'm a very, very opinionated tester.I truly think, if you're testing, you really wanna truly test something, not forthe sake of writing some garbage unit test to prove to your senior engineer team thatyou have tests.But you actually wanna get value out of your tests, right?It's not about writing tests for the sake of telling people you write tests,it's you get anything out of your tests.And for me, writing a fake to mimic my test database is kind of a waste of time.I believe in mocks, and I believe mockery, and we're gonna use potentially mockery,if we have time.But if I'm interested in testing a database, I wanna know,am I testing the database?And so that's my philosophy to it.It's a bit more, I guess, rigid, butI do hope that once we see it working, there is some of appreciation to it.And if it's not your kind of cup of tea, that's totally fine,go with whatever you feel is necessary.But because we're also not using an ORM and we have our own SQL,we are literally writing SQL ourselves.We're processing the rows individually, I wanna know, really,if we're doing it correctly.So in the dockercompose.yml file, right underneath the db,we're gonna create another service called test_db.Again, you can just watch your spacing and to save us time,go ahead and just do the old Ctrl+C, Ctrl+V here.Do like this, [COUGH] and then underneath, after the container_name,workoutDB, just append test to it.It's still gonna be the exact same image that we're going to pull.The volumes, so on the right we have /database/postgres,we just do a -test-data, the rest is fine.And the last part you need to make sure is the port here.I know some people who have Postgres already runningon their machine faced a bit of an issue with the port 5432, andthey may have moved their original db to 5433, or to another port.Whatever is you have to do,just make sure that your test db is not on the same port as your regular db above.[COUGH] And again, it's fine if the right hand side of the colon is 5432,that is, the port of the container.So since these are gonna be two separate individual containers,they're not gonna be intersecting each other with what ports they are going to bebinding the software with.Cool, all right, now, since we have this, we can save this.And if you go back to your document post, mine is still running,I'm gonna go ahead and nuke this.I'm gonna bring it down, and then I'm just gonna do docker compose up --build.And now you can see, not only do I have the workoutDB running as per usual,I've now actually pulled and created a workoutDB_test.
7.2 Connecting to the Test Database
05:12:27 - 05:19:50
>> Melkey: In the store folder, we're gonna make a new file calledworkout_store_test.go and the test append at the end is specific.We need to actually have that to let the built-in tester and go, andidentify this file is going to be used for testing purposes.So let's go ahead and build this.It's gonna be in package store, andit's gonna be a few things we need to actually initially bring in.So there's this really good package that I need to share with you guys,it is called stretcher testify, if I will go out in a limb here andsay if you've done any form of testing and go, you have used this package.It is like the industry standard for testing in go.As you can see, it's 24.1 1000 get up stars,it's a great tool kit, it's used by just a lot of people.And like I said, it's the golden standard to use within go, right?And it allows us to have a bunch of these really nice function utilities to assertdifferent values in our testing cases.So you can see here, do these values equal?Do they not equal?Is it nil?Do I expect an error, etc, etc, and also give us this little,nice mock thing that hopefully we can also explore.So with that, let's go ahead and install testify.So if you want go back to terminal,go to any empty terminal that you have in the root of our project.>> Melkey: Okay, and then what we can do is just install,let me just see, right here.Go get github.com/stretcher/testify.And it's a go get, we don't have to do go install.We don't need it to be binded to our bin or our path cuz it's not any nativecommands we're gonna be using that testify offers, all right?So with all that said, we are going to first build a helper function forus to connect to our test database, okay?Now, just as a reminder, the test database,we should never touch this test database outside of this file, like ever.This is a database that we are gonna use, andthere's action argument to be made in the Docker Compose, you can separate them.You can have one Docker Compose to run your local DB andanother Docker Compose to run your test DB.So that you're not running two DBs at once.I did it here just to kind of save a file and have it one, butif you want, you could have two separate DBs running.Let it have your local DB and just have the test DB running forwhen you run this test suite.And the purpose of this test suite, it's a bit of this blur line between a mocklike a unit test and like an integration test,because we're truly going to be calling and querying our database.And because of that, what I call these unit tests,I'll call them more unit tests than integration tests.Even though we are integrating with a database, my definition forintegration test is a full end-to-end test suite that involves multipledifferent services across the scope of your application.But again, these are just my definitions and my approach to this one topic.That's enough talking, let's go ahead and write some code.So here, the first thing I wanna write is func, I'm gonna set up testDB,like so, and this is gonna take an argument that we haven't seen before tobe a pointer to testing.T, all right?And testing, we're gonna import it is a standard package in the Go library, andit provides us testing fixtures that make testing very, very easy in go, all right?And what this is going to return is a SQL database like so.[COUGH] And we're gonna do is dB error.We're gonna make the same connection string, connection string,so we can do open, okay?Here we can bring in pgx.And to do this, we can also bring back the same import from Jack cpgx.So in the import, go ahead and just import github.com/jackcpgx before standard lib.This is already an import that we saw in database.go, all right?And the second argument in the SQL open is the actual connection string.So here, we can do host=local host, users gonna be postgres, okay?The password is also going to be postgres,we'll have the DB name equal to postgres and then the important part is the port.So my port is 5433, okay?And this is from my test database, my real database is running on 5432,just try and make that clear.And we'll do SSL mode equals disable, like so.Let's always check the errors.If our error does not equal to nil, we're actually not going to return an error,we're actually going use our texting fixture and do a fatal.And we'll say, opening test DB,we can just put db here as the error like so.NT fail covers any return, so we don't need to explicit rate returnat the end of this it's going to complete fail or test case.So here, we want to run the migrations for our test dB, okay?And the way we can do this is pretty simple, we can do error.We can just say, migrate, not Fs, just migrate.We're passing that dB, andthen here we're gonna pass in the path to migrations from where we are relative.So it's just gonna be two folders up.And you can see we have migrations over here, like so.>> Melkey: If our error does not equal to nil, what I wanna do is just again,do a t.Fatalf, t.Fatal format, okay?I'm gonna say, migrating test dB error andslide the error inside like that, okay?And then, one other instance is, like I said, test dB,it should be a blank slate every single time you run our tests.So I wanna add a function here, andthis function is basically going to truncate everything in our dB.Now let's do backticks, so truncate, okay, workouts and workout_entry.And we'll make sure it cascades.And what this does is basically to allow us to wipe the dB every time wewant to run our setup tests.And I definitely recommend doing this,it is not the most performant way, I will admit.But the reason why I like this is, in between test suites,test functions, I don't want the test that I wrote andcreate workout test to potentially contaminate the tests.I want to run on update workout or get workout, delete workout.I want the dB to be absolutely empty.I wanna insert the values, I wanna test for deletion andthen delete them and make sure they fully got deleted, or forany kind of combination between the CRUD operations, okay?And then here, all we have to do is return dB, like so, orwe can catch this error too, I think I forgot to do this.So if error does not equal to nil, we can again just do T.fatal,we can say truncating tables error, like so.
7.3 Testing CreateWorkout Success
05:19:51 - 05:26:21

>> Melkey: So now that we have the setup test function, Go has a pretty coolfeature that, you saw that this file has test at the end of its file name.This lets the Go tester, which we'll explore, identify that it's a test file.But now we wanna tell that tester, that Go's built-in,tester, what functions are actually tests.And we can do this very simply by just writing a function with the wordtest in it.So we can do TestCreateWorkout, like so.It's going to take our fixture, t, testing.T, okay?It's not gonna return anything.And here is where we're going to define not only our TestDB, butwe're also gonna define our Table tests here.So first things first, go ahead and do setupTestDB(, pass it our fixture t,will defer db.Close, I don't have any loose connections.Or lingering connections, I think it's more appropriate.And here we can actually get the pool.PostgresWorkoutStore,the actual WorkoutStore we're using.We don't need to make a fake, we don't need to make a mock.None of that, we're gonna use the real deal.What we're gonna use in production is what we're gonna use here in testing.And so the goal of testing for me is to get as close to the real deal as possible.So we have the store, new.PostgresWorkoutStore.And here we're gonna create our set of tests.So we have this variable tests, we can declare it as a slice of structs, okay?And then we're gonna make sure we format the struct correctly.So again, the first curly brace is the fields identifying what that struck is,and the second set of curly braces fills in those fields, okay?Again, this is an anonymous struct.So for our tests, every test needs a name.This helps us know what tests are failing, so, Name string.For this particular test, we're gonna be testing how to create a workout.We're gonna test workout, and there's gonna be a pointer to a workout, like so.And then we want to see, do we want to check if this is going to error or not?We wanna check happy path, and the not-so-happy path.So, WantError, this is gonna be a boolean, like so.So here we have defined our anonymous struct.It has three fields, all of different types.And then here, because our struct is going to be a slice of these structs,every entry in the second set of bracketsneeds to be separated by its own individual set of curly braces to.To identify one individual workout, or one individual entry in the struck.So for example, we can do our first workout as name, our first test.And we can say, ValidWorkout.All right, that's gonna be the happy-path test.We do not expect this to fail, all right?We want this to work completely fine.And if it doesn't work, it's gonna identify something is wrong in our system.Here we'll do a workout, and it's going to be an address to workout.Okay, and here we're gonna pull in the details for what work we wanna use.So these details, let's make sure we get them correct, So Title B, Push Day.All right, we'll do our description.We'll say upper body day.Duration in minutes, we'll make it 60.So one hour.Calories burn, we can say something like 200.And then for entries, right,we know this is going to be a slice of our workout entry, like so.And again, because this is a slice, every entry in the workout entry sliceneeds to be defined with its own set of curly braces.All right, so here we can define every entry in that workout.So here we can say, bench press,sets, we could say 3, all right?And now, here's gonna be a bit of a fall.So, reps, let's say I did 10 reps.There's gonna be an issue, right?If I fix this, can I use 10 untyped in constant as pointer int value?Okay, so you may be thinking, let's just do something like this.That also doesn't work, right?So the issue here is because, if you remember, it's not kReps,excuse me, it's just Reps.The issue here is, if you remember, when we first started to createour WorkoutEntry, we determined that the type for reps andduration in seconds are gonna be pointers to ints.And for Go, you can't just in place saythat this 10 is going to be a address of 10, right?You have to declare a separate variable and then use that variable accordingly.You can extract the address of that variable.Now, what I'm going to do, just to help make this a little bit nicer,I'm gonna make a new function called func.I'm gonna intPtr, so int pointer, it's gonna be (i int), andit's going to return a pointer to an int.And this is going to be simply a helper function that allows me to extractthe address of whatever variable I pass into this.Okay, I'm gonna repeat this for a float.So, instead of int pointer, oops, I'm gonna call this float pointer.And the argument is not long to be an int, it's gonna be a float 64.And the return is not gonna be a pointer int,it's gonna be a float 64 bit, like so.But continuing on, we're gonna do int pointer, I'm gonna pass 10, okay?Then we do our weight.Again, weight is a pointer to a float 64 bits.So we're gonna floatPtr, I'm gonna put 135.5.And then here we'll do Notes, and here we'll write, Warm up properly, okay?And then the order index will make 1, okay?So we're not fully done yet, because we are missing one more field.And do we want this to error?And since this is our valid test case, no, I'm gonna set WantError to false, okay?>> Speaker 2: Since you're using a slice of test cases,would all tests run even if one fails?>> Melkey: Will all tests run even if one fails?So, that is actually fully up to you.I'll show you, and like, once we range over the tests,we use the fixture to run each individual test in our slice here.And if you explicitly face an unforeseen error, it stops it.So it does not continue.It just stops the flow of the error.But also it's up to you how you wanna handle it.You can actually explicitly say to return, if you want a certain error or not.And I'll show you how that looks like.
7.4 Testing CreateWorkout Errors
05:26:22 - 05:35:34
>> Melkey: So we have this happy path error,let's also create some not happy errors, right?Some paths that we want to error, these should be errors, right?We can see the name of this is going to be a workout with invalid entries.Okay, we can do the workout, is going to be workout like so.And feel free to copy and paste the values from workout up here,like the tile description, duration, minutes, calories burned.>> Melkey: If it makes it typing easier.So I'm gonna make the title as full body.I'll make description as complete workout, duration,we'll make it 90, and calories burned, we'll make it 500.Doesn't truly matter.And here in the entries will be a slice of WorkoutEntry.>> Melkey: Right, and here we'll have two entries to demonstrate itcatching a potential problem.So here we'll make the exercise name, plank.Okay, we'll say this is just sets three, reps for a plank.We could do something like 60.We could do notes and order index, so this should be fine.>> Melkey: And this would be one.>> Melkey: Cool, and then here we'll add another entry into the WorkoutEntries,and this is gonna have the constraint that we have.So let's go to exercise name, we'll say squats.Sets, we can set as 4.Reps, we can do int pointer as 12.And then here we'll put duration in seconds.Now, if you remember, we can't have both reps and duration in seconds.We expect this to fail on us, right?So that's why this is gonna be a test case.We want to capture our error.So duration in seconds would be an int pointer 60.We can do weight, it doesn't really matter, FloatPtr.Just put this as whatever value you want, 185.0.We can put notes as, Full depth, and OrderIndex 2.Okay, and one more thing, for this case, do we wantErr true?>> Melkey: [COUGH] >> Melkey: Cool, sonow that we have the tests fully created, >> Melkey: To make sure,right here, so outside of the slices of your test,we're actually gonna go through them individually.So we'll do 4, unless we can ignore the first variable in test case,in range of tests.So the test we just created, we're gonna leverage our testing fixture.So we do test.run.We'll pass in the name of every individual test, we know what's currently running.And then we're gonna bring in an anonymous function.Okay, and this anonymous function is gonna be responsible for actually runningthe test that we are curious about, or that we want to know about, right?So this func testing, so here, we can do createdWorkout error.Is going to be store.CreateWorkout, you can pass in tt.workout, like so.It's testing.t on the fixture.>> Melkey: I forgot to add it last time.Okay, so here we can do if, our test case, if we want an error.So if this is true, we expect store.CreateWorkout to in fact error out.So we can do assert, right, and we should actually bring in thatassert package, cuz sometimes my LSP brings it in randomly.So it's github.com/ is going to be the stretcher package.So, stretcher slash testify, we can bring assert.>> Melkey: Says I don't have it, so let's see.>> Melkey: And we get to do slash assert.>> Melkey: It's stretch.There you go.So here we can then use assert, okay, and since we expect this to be an error,we can do error.>> Melkey: Okay, give me a second.And with this error, we can just make sure that we pass in that texting fixture t,and then the error that we expect from the call of CreateWorkout, andthen we can return.And so this explicit return will stop the test cases, right?We're gonna actually get out of the test cases here, or the test suite, okay?So if If we don't want this to error, we expect this to be a happy case.So what we can do is require no error, okay?We can call it t, and then error.So this is gonna validate that error is none.Okay, so here, we require that no error.And then here,we can just start asserting the fields we expect to have in our created workout.So here we can do assert equal, and pass in our t fixture,and here we can make the workout.title.We can make sure this matches created workout.Title, right?We can just copy and paste this a few times.We could do title and description, so like, description, andthen we could do something like, DurationMinutes.>> Melkey: Like so, and DurationMinutes, right?So we're gonna make sure that whatever we're answering via created workout is,in fact, gonna be what we're inserting for the text case that we've assembled, okay?And then one other thing I like to do is, because we have an actual database,we can actually also retrieve it.Since we created it, we know it's gonna exist in a database.Why, now we see what happens when we pull it out and does it still matchthe values that we want it to when we initially inserted it, right?So here we can do something like retrieved error,is gonna be store.GetWorkoutByID, okay?And then we can cast the type, you can use in 64,we can cast the type using CreatedWorkout.ID, okay?So let's make sure, AcquireNoError NoError(t, andan error like so, to cover the error from GetWorkoutByID.And in here we can do assert.Equal, pass in our t fixture, andwe can do createdWorkout.ID.Matches the retrieved.CaloriesBurned the ID, like so.We can also assert.Equal, okay?And for all of these functions, it first expects the testing fixtures,that's why I'm passing in t continuously.You can also check that the length of tt.workout.Entriesmatches the length of retrieved.Entries, all right?And this is pretty good, but we also wanna check the actual entries themselves.So here, for i entry in range retrieved entries, okay?Now we can iterate through every single entry that we have in our entry slice andsee if they are in fact correct.So, one thing we can do is assert.Equal t,tt.Workout.Entry.We can index it by i to get the specific one,ExerciseName matches the retrieved.I guess we also just do entry, >> Melkey: Retrieved,not title, but retrieved.Entries.We can also index it at i, and can do, ExerciseName.And then can, if you want, just remove the entry here or use it.>> Melkey: I think I personally like having this a little bit more explicit,just personally, with the iteration i using the index, butI'll leave that up to you.And then we can do this on a few more fields.So instead of ExerciseName, we can check something like sets, oops.>> Melkey: Right, and we can also check another field like OrderIndex, forexample.So here, GetSets.>> Melkey: Here, OrderIndex.Interesting.So that's why I did v.So fatal f does not support error wrapping directive, module w,that's why I did v, Michael.>> Micheal: I just noticed those OSP warnings.>> Melkey: Yep, so the texting fixture,fatal f doesn't get the error wrapping module of format specifier.So we have to use the v, that's like a catch all, struct one.>> Micheal: Okay.>> Melkey: I knew there's a reason, but I don't think my LSP was,when you asked the question, I don't think it was pulling up.
7.5 Running Tests in Go
05:35:35 - 05:42:34

>> Melkey: This is going to be us creating the func test create workout andin this case, we'd actually go ahead and run it and test it out.So if you go back and make sure your database is running,especially workoutDB_test, if you chose to separate it or not.And there's a few different ways you can do this.I recommend go cd into internal, cd into store.All right, if you do an ls, you should see workout_store_test.go, all right?And if you run go test, >> Melkey: Relation,let's see, truncating was workout and tires, classic.I knew I was gonna do this one time.I have a mistake here, workout entries.I even said it think yesterday that I always type it as entires.Workout entries, okay.If you run it now, go test, it passes.So there's a few things we're gonna go back and to see what is really happening.So first, to run a test, there's actually built in test command in Go, so go test.And then we use this indicator to test everything in this directory that weare in that you can, right?And so it goes to the test you can see in the failure,it's a bit more explicit that on the failure,you can see very similar to when we ran our Docker compose the first time.It's migrating the user's workout and workout entries as I wanted it to.For every test suite,I want this to be like a new fresh db that we can check and validate.And then you can see in what function test create workout, we got this error.It tells me where the error is with the line right here andwhat the error was itself.So here I had a typo in workout entries, all right?And then we ran go test and we see, okay, this means all the tests pass,but what does it look like if the tests don't pass, right?So if you go here back to something like this, right?So let's say instead of false for the valid workout, for some reason,do we want an error?Okay, so if I go back and run the exact same command, go test,you should see here, right, the name of where it is.So test, create workout, valid workout, which is the name of our tests, andit's the error trace, right?So it gives me exactly where it is, line 97 in what file,and an error is expected, but got nil, okay?And so we error out on our test suite.So that's kind of how it looks if you have passing tests and then test that fail.So the stack trace does a pretty good job of explaining orgiving you all the information you need to kind of debug and see what's going on.Does anyone have any questions in terms of the testing tables, the testing fixture.Why I wrote this test the way I did?Is kind of making sense?>> Speaker 2: I have a more like general question.>> Melkey: Yeah. >> Speaker 2: Is it pretty standardpractice to co-locate tests with the files that they're testing?>> Melkey: Yeah, so I kind of put that into a projectstructure umbrella question.For me, I like to co-locate if I have the workout store,I like to have the test right there.I know some people like to do a test folder within a package,that's fine, it's up to you.But remember, if you have your test outside the package,pulling stuff like the store can be pretty difficult.Right here, we have our ability to get call of these because wedon't have to import anything, right?New Postgres Workout store exists in the same package, which makes itsuper easy for me to not even have to worry about these imports, right?But as most of the answers always go,it depends on what you want.This is kind of my style, this is what I'm used to for testing stuff.>> Speaker 3: Is there a command that parses the whole project andruns all the tests.>> Melkey: Yeah, like all in one, yep.So instead of going, into a folder, folder, folder, folder, folder,you can go all the way back up to the root here.So I'm at the root, you can run go test andthe amount of folders you want this to dive deep into.So remember, in the other one the command, this is gonna be kind of hardto demonstrate, but the command was just go tests, and then the single dot,because we were already in the section of where we want our test to be.Here because we went out a few directories above and we're at the root,we have to tell go, how many layers deep do we want to fully run all the tests?And you can see here we have node test files, API, app, routes, utils,no test file.It finds one in internal store, it's like, this is cached,I don't need to do anything.You didn't change it in your test file, it's the same result.But that's the command.So I am not gonna continue running tests in this file, just for a few reasons.One is time and one is like, it gets pretty repetitive.I do want to kind of emphasize, I'll take this opportunity to discuss againthe approach of the style of the test, right?So I think table test is something, it's fairly obvious.It's just a slice that we iterate over, like there's no magic there.But when you do want to create your own test, especially data store tests.My recommendation is to really test the shit out of it.And excuse my language, but here we're creating the workout, that's good.We're validating this, but I also took it one step further, and retrieving it.So not only am I doing a write request to this test db.I'm also getting it back and validating, right?So I'm kind of really exercising the fact that it's like a db that we can use.So go ahead and fully test it.What do you expect this to work, right?If you're manually testing and this actually helps, right?Now, if I were to add a new end path, or another file, excuse me in,that was weird.Here, instead of manually testing it, going back, okay,it's here, okay, let me go back.Let me create the curl, okay, I can just create a test for it now,super easy and check if it works or not.So there's some advantages to testing for sure.And again, this is just kind of my style of testing,especially for database layers.>> Speaker 2: Someone just mentioned that the repetition of testing is nothingcompared to writing error not equal to nil.>> Melkey: [LAUGH] Tell them they are right.

8.0 Authentication
1h 20m 4s
8.1 Managing User Data
05:42:35 - 05:48:25

>> Melkey: So we just wrapped up testing on a database layer.We're gonna quickly shift gears to user and authentication methods,and we're going to kind of explore how that's going to look fora Go back-end application.So the first thing is, this time, we actually start from the lowest level andmove our way up.So we're gonna create a user_store.go file in the store package we have up here.>> Melkey: Okay, and in this package it's going to be responsible foreverything to do with our users and the database.Now, like I've said before, every time you open a new file,you're gonna ask yourself, is it gonna hold data, right?The answer is, yes, there's gonna be user data.How are gonna handle that user data?What are we gonna do with that user data?So with that, we can go ahead and create our very first user struct.So here we're to type user, there's going to be a struct, like so.It's gonna have an ID of int, json:"id", right?It's gonna have our username string.>> Melkey: Username, email.>> Melkey: Email like so.We're gonna have, our next part is the password_hash.All right, now, password_hash isn't going to be a string, butI'm gonna leave it as a string right now, okay?You'll see why in just a second.And then here we're actually going to omit anything in the JSON field.And what this dash does, basically says, no matter what we encode,decode, or write, we are going to ignore the value in this struct.Just so it completely voting passed from our end to the client end, okay?Next, we're gonna have our bio to be a string, can do bio like so.And then we can add the other fields, as well as create at,which will be of a type time, .time.Okay, so import the time package, new JSON created at like this.You can go ahead and copy and paste this to make updated at.>> Melkey: And another field we are very interested in is the Postgres struck,that will handle the database communication.So we can do type PostgresUserStore,in itself is going to be a struck, andthis struck is going to have a field for sql.db, like so.Import DB.>> Melkey: All right, and with our struct, let's make a new constructor.So we can do func NewPostgresUserStore.Okay, this is gonna take one argument, which would be DB, pointer to SQL DB,and it's going to return a pointer to PostgresUserStore.I'm gonna return this, like this.I'm going to say, oops, not like that.Return PostgresUserStore, put db as db, all right?So pretty fundamentally, the thing we've seen before,the structs, the constructors, and the Postgres struct as well.And with that, let's go ahead and create the interface.So type, we'll say, UserStore.It's going to be an interface.And this interface is gonna have three methods.One's going to be create user.It's going to take a type of user to return with an error,and have GetUser by user name.It's gonna take a username as a string.It's gonna turn a pointer to user and an error.And last is gonna be UpdateUser(), okay?And this is going to take a pointer to a user and respond with an error.Now, before we continue, I wanna bring in another package,it's gonna help us kind of, handle hashing the passwords.So here if you open up your terminal and you go get bcrypt,this is not from GitHub, so let's go get golang.org/x/crypto/bcrypt.>> Melkey: Okay, should install without any problems.[COUGH] Let's go ahead and bring in bcrypt into our project.So it's again, golang.org/x/crypto/bcrypt, okay?Input not used, this always a decent sign.And now we're going to actually handle the password,cuz right now it's a string, we don't want this.I actually want my password to be its own struct.So here I'm gonna define password lower capitalization, so lowercase.It's gonna be a struct.It's gonna have a plain text.Okay, I should type it like this.It's gonna be a pointer to a string.And I'm gonna have the hash, which is going to be a slice of bytes.>> Melkey: Okay, sothen we can replace password hash from a string to a password type.So we're gonna do some nested structs here.>> Melkey: I'm gonna leave this for right now.So we can actually go back, if the compiler is annoying you,put a little underscore there, cuz we will come back to bcrypt.I just wanna put a pin on this for right now.

8.2 User SQL Queries
05:48:26 - 05:56:36

>> Melkey: So now that we have the interface, we have all the structs,we can start writing the functions for the things we have here.So first, let's go ahead and create user.So we're gonna do func.You could do, I don't know, s *PostgresUserStore.It's going to be called createuser, right.It has to, again, match the method of the interface there,the signature so user be a pointer to user.I'm just going to turn an error like so, andthen here we're gonna create our query.So exact same foundational things that we did earlier,nothing new is really changing.So here we're going to insert into users.We're gonna do all the fields we care about, so username,email, password, underscore hash, and then bio values.I'm gonna insert four values, so one, two, three andfour, username, email, password, hash and bio, okay.And here we can just do something like RETURNING id.And if you want for users, foranniversaries of when they created the account, orif you want to store that sometimes you see this account was created.So, like on Twitter, you can also return the created at andif you want also the updated at.Okay, and then here we can just do errors, it's going to be s.db.queryrow.I'm going to pass in that query like so and then all the fields as they appear.So user.username, user.email,user.password hash.hash, okay, and user.bio,it's going to yellow this because we need to use the scan method now andscan the returning fields into the appropriate fields here.So it's ID created at and updated at, again, these have to be addresses.So we can do user.ID,user.CreatedAt andthen user.UpdatedAt, like so.For standards, go ahead and check this error.So if our error does not equal to nil, we can do a few things.We can just return error actually.>> Melkey: Okay, otherwise, let's just return nil.Let's move on to the next function, which is get user by user name.Okay, so we just do us PostgresUserStore, GetUserByUsername.It's gonna take the username string and it'sgonna return user and an error, like so >> Melkey: Okay,we're gonna first define our user.So here we can make it define a new user like so.Okay, and we have to instantiate the password, so password hash, andwe can just do it's gonna be password like so.>> Melkey: Okay, let's go ahead and run the query sowe can do SELECT id, username, email,password_hash, bio, created_at andthe last field is updated_at.From our users table where the username equalsthe one and only value we're gonna pass in.And here we can declare our error as sdb.We can do QueryRow pass in that query,like so, and all the fields that we want to see,which is just username,okay.But then we can scan, and I'll open this up just a bit easier to read.And because we've declared our user a few lines above, it's going to be pretty easythat we can just do user and start pulling in those fields.We can do user.Username or sorry,the first field is ID, okay?User.Username >> Melkey: User.email,okay, then we can do user dot, oops,user dot password hash dot hash like so.Okay, in the user.Bio andthen user.CreatedAt, user.UpdatedAt.>> Melkey: And as we know with the select clause,it's not guaranteed to return anything, but nor is that an error.So we can handle this with if error equals sql error no errors or no rows excuse me.You can simply do return nil and nil, if our error does not equal to nil,so if something wrong happened, if you turned nil and the error.Okay, otherwise, we can go ahead and return the user andnil like so let's rip that bandit off and create the update user function as well.And then we will not have to be in this file anymore for a little bit.We do func and feel free if you already kind of know where we're going with this,write it out as I'm writing it to maybe have,if you have to look up to see if you kind of stumble, it's a good way.But I encourage everyone just to try it out as well.So this UpdateUser, I'm going to say user,pointer to our user, like so and so this is update user.All we care about is if, if there's an error or not, we don't necessarilyneed to return the full user up to if you want to implement that.Okay, I'm gonna define the query here and here I'm gonna update the users table,we're gonna SET username as the first value we potentiallycould be getting,email as the second, bio as the third.And an updated app, we can set this to CURRENT_TIMESTAMP,which is a native function in Postgres.Where id lowercase equals the fourth value,okay, returning updated_at, then we can do result anderror sdb I'm gonna execute this pass in that query andthen the four variables it expects.So user.Username, user.Email, user.Bio, okay?And then user.ID.Let's check that error, if error does not equalto nil let's just return that error back to our caller.With an update, we're gonna see how many rows were affected.So we can do rows affected.Error is going to be result.rows affected like so whoops.Okay, we can check this error if error does not equal to nil,let's go ahead and also return that error.>> Melkey: And if rows affected is zero we canjust return sql.ErrNoRows.Otherwise we can return nil.


8.3 Validating User Data
05:56:37 - 06:04:55

>> Melkey: With the database layer done, let's go back into the API.Let's go user_handler.go.And we're gonna mimic the same behavior we had with the workout handler, butnow we're gonna have it with the user handler, okay?So first thing, let's go ahead and create the package API.Next, let's do a UserHandler.It's gonna be our struct, this UserHandler needs to have two fields in it.One is going to be the UserStore, so store.UserStore, which are interface andthe second thing is the logger, which is going to be point to log.logger.Right, underneath, let's go ahead and create our constructor, sofunc NewUserHandler.This is gonna take the UserStore of type store.UserStore, andit's also gonna take a logger, pointer to log.logger.It's gonna return a pointer to UserHandler like so.In the function, we can just return the address of UserHandler, like so,user store is gonna be UserStore and logger is gonna be logger, all right?And something different I'm going to introduce into this section is,we're gonna have, again,remember we had that validation request from updating a workout.We're gonna extract that over here, so we can do something like typeregisteruserrequest, this is gonna be its own struck, like so.It's gonna have its own field, so we're have username, we can do some like string.You can have them as pointers, I'm not gonna use points forhere because this is for specifically registering a user, sothese are fields we want to assure our mandatory, right?There's a bit of a difference between creating something and updating something.For the update,that's what we had those pointer types to check if they are nil or not.Just again, because it's go the zero values could be a bit of a gotcha, butbecause this particular struck is going to be used for creating a user,we can kind of take them more at face value and not have that validation.Again, you don't it's just added protection, if you want,you can definitely add a pointer and do those same checks here, butsince it's already implemented in a previous file,I'll leave that up to you to use if you like it or not.So here we have username string, we can just continue on with the JSON.So we can put username, like so,we can have our email string can be, oops, JSON email.Okay, we're gonna have our password.It's gonna be a string.Again, this is the password that we get from the caller, okay,we do password, and then we can have bio, which is string.Let's read bio, like so, okay, now for server side validation,like I just finished talking, we don't have those pointers, andwe don't really need the pointers.However, we can still add some sort of function to validate,is the email properly formatted?Is the password, less you can't put a password one character, right?So we can have those validations on our file here, again,you can have them in the front end for client side validation.I don't see a problem having them on the back end for backside validation as well.And I think it's just useful to demonstrate how this could be done.So we'll just do a method on our UserHandler.We can call this validateRegisterRequest, okay?And this is going to take a pointer to that new register request.Just struck that we've created andit's going to return an error or no errors, okay?And here, it's pretty simple,we can do ifrequest.username is like, empty, for example, right?We can say return errors dot, oops.So we've seen this when we looked at the error SQL, new errors,we can say username is required.>> Melkey: Okay, andwe can create this new errors using the built in errors package and go,so errors.new, and here you can go nuts with all of the constraints that you want.The username length, the username, if it's too short, too long,you can add them here, I'll show one example, right?If length, sorry, if lengthrequest.username,let's say this is greater than 50.Well, this can be an error.First, we return errors.new, we can say, username cannot begreater than 50 characters, something like that, right?So however you wanna handle usernames is totally up to you.We can do the same thing with email.So ifrequest.email is empty, since it's a mandatoryfield in our database, we can return errors.New.I'm going to say email is required, okay?And I think a more interesting one, which may require me to push andyou guys to pull down in just a second, is the regex component of an email.So go has a standard library a Standard Regex library, and it's pretty good.It's a pretty good Regex library, I'm not gonna try andclaim, I'm like a Regex master, I can't read Regex, I don't believe people thatcan read Regex, I don't believe them, they're wizards.But, essentially, it doesn't hurt us to also have a validation for Regex, okay?So here, we can do something like email regex.We can bring in the regex standard library, so regexp.I can use the must compile function here, and this accepts a string.I'm gonna particularly use backticks.Now, I'm gonna copy and paste what this is, I'm gonna push the code up.So here, I'm gonna grab this.>> Melkey: And this is the formatted for an email in regex, according to Google.So continuing on, we can say if emailRegex, right,if it's not matching these strings, so this method,right here, match string into the request.email.Okay, so if this is false, meaning the email does notmatch the regex email formula we have, we can return errors.new,and we can say something like invalid email format, okay?And so, again, we can imagine this like, we can have password validation as well.>> Melkey: I can quickly just show you one, but I think it's fairly obviouswhat what the thing is you can do ifrequest.password is empty.You can see return error.New password is okay andyes, I agree that this would probably andshould be done with the front end.But what if your front end is written by someone who doesn't know whatthey're doing?Or what if you wrote the front end like a 3 AM when you're buzzing on Red Bull,jewels, Zins, everything the devil's on your shoulder.Like, it's easy for things to slip right up because it's said to be done on oneside of your application, doesn't necessarily mean it's, a, done correctly,or b, can have negative consequences on your back end.And further strengthening my point, stuff slips on the front, big whoop.Your form is gonna miss the value, okay?Here, if we accept values and persist it into a database, that's big trouble,that could actually have some some consequences, right?Now, our database is, I won't say the word infected, but it has improper data.Yeah, so that's why I always,personally like to add the extra stuff of my own back end validation.This is not gonna cover all the cases, butwhat it does try to do is validation that you see in on the front end.You can easily copy it on the back end as well.

8.4 Register User API
06:04:56 - 06:09:55
>> Melkey: So with that,we're gonna create a function that allows us to register users, okay?So the function is gonna be pretty easy, I'm just gonna go and make some space.We can do funk, I'm gonna do h,I'm gonna make it a pointer to our user handler, like so.And then here we'll do handle register user,it's gonna take WH, TTP response writer and then a pointer to HTP request, like so.All right, in this two-step process, we should be fairly familiar with,we can do a var request, which you can be of type registerUserRequest.And then we're gonna decode the values we get from the R body into this particular variable here.So we can do err is gonna be json.NewDecoder,pass it r.Body, okay?I'm gonna decode this into the address of that request like so,if error does not equal to nil, then we can do a few things.We do h.logger.Printf for ourselves,say, ERROR: decoding register request, okay?>> Melkey: Oops.>> Melkey: And we could also bring in the utils.WriteJSON library orfunction that we created earlier.And here we can do w, http.StatusBadRequest to bring in utils,that envelope we can say error, can say invalid pay request payload.>> Melkey: And then make sure you return.>> Speaker 2: So we only created that type at the top, basically just encoded?>> Melkey: We created type- >> Speaker 2: On type at the top of the register.>> Melkey: Yeah, this one?>> Speaker 2: One requires just to basically have a dump.>> Melkey: Yep, yeah, so we have like this structs gonna hold that data, right?Which is kind of like the definition of structs, it just holds data, and you can use it across your application.So it's just an easier way for us to extract the value from our body into this not permanent data structure.>> Speaker 3: Would you on a project have some sort of maybe globally defined errors across the project, like they did with, I can't remember, we were looking at the SQL package, and they had- >> Melkey: Var error,this one actually var SQL error, yeah, absolutely,there's many different ways you can do it.I for one, you can have even a file called constants in your internal whatever.And that constants package could just export a bunch of things for it to use,like errors, different print statements, you can have that.Depends on how big the project gets with the scope of it,you can reuse the variables like definitely use the same error.And you can declare there, but yeah, that's a pretty common practice have like a constant.go and you declare everything there and it's exported.Okay, so we have this handle, our registered user, so at this point,we can assume we've decoded everything safely and securely into the register user request into that dump struck.Now we need to validate it, and how can we validate?Well, we actually have validate register user request, so put it there, and this has to be addressed like that, right?So now we can decode it, but that's not validating yet, right?Now we have the valid register request there,we can handle this error, but if error does not equal to nil,we can do utils.WriteJSON(w, http.statusBadRequest).And in here we can do utils.Envelope, you put error, and this time it's gonna be err.Error like so.Because we've created that error message using the errors built in package,and then don't forget the return, okay?Next, we can go ahead and create store.User, so this is the actual user, we are okay to persist into our database.We can make the username as req.Username, and we can also make the email as request.Email.>> Melkey: Because bio is an optional field,we can do if req.Bio does not equal to this empty string,we can then also insert user.Bio = req.Bio.This could also be in its own function in the validate request function,if you want.
8.5 Hashing & Storing User Passwords
06:09:56 - 06:21:57
>> Melkey: But now comes the how do we deal with their passwords, okay?And there's a very elegant way for us to deal with the password here, okay?First thing is we have to hash their password,everyone who see their password store them.A good rule of thumb is the less data you store,the better it is to maintain your app.The more PII, the more other stuff,then you have to kind of jump through all these hoops, regulations, and it just makes your job harder and tougher and more prone to attacks.But in our case, because we do wanna store user passwords,we're going to have to hash these.And so, how can we do this?Well, if we go back to our user_store.go file for just a second,you'll notice that our password is its own struct.And we know because a password is its own type or own struct, it can have its own methods.And this is a very powerful thing for us as we continue to create methods that a hash the passwords.And then when a user logs in, we can use that to see if the password they're passing is the plain text representation of what we have in our database.So here we can do p, it's gonna type password like so.Oops, and the first method we're gonna create is called set.I'm gonna take a plaintextPassword as a string and it's going to return an error, all right?And if you still kept bcrypt in you import now's a good time to remove that,ignore import, because here we're gonna do hash, err.I'm gonna write bcrypt, if I'm not mistaken,I think bcrypt only has a few methods we can do GenerateFromPassword, okay?And we're actually gonna transform that plaintextPassword into a slice of byte.So we can do slice byte, and we can pass in the plaintextPassword like so.And here would be the hashing algorithm, the salt.So I'm not gonna try to pretend I'm a security individual.The thing I know is the higher this value is,the more secure the hashing algorithm will be for hashing the password.However, the longer the compute time it takes to do and process that.The lower it is, the less secure that hash will be, but the faster it is at computing that hash representation from plaintextPassword.I think standard documentation shows 12 as a good middle ground.But again, this is depending on the need, depending on how it is,depending on what computer you have available.You can dial and tune this value accordingly.So here, if err != nil, we can just return that error like so.Otherwise, we can do be p.plainText is going to be plaintextPassword.And p.hash is going to be the hash like this, and then we can return nil.So we have one method to set the hash,we have to have another method that compares the hash representation.So if a user is logging in, that hash representation to a plain text,they could be submitting on the former.If you log in, you typically log in with a username and password.So you wanna make sure that that plain text representation of the password matches the hash that we stored in our database.So to do this, let's make another function, p.>> Melkey: Password, and we're gonna call this function Matches like so.And it's gonna take a plaintextPassword which is gonna be a string,and then we're gonna have a bool and an error, like so.We're still gonna depend on bcrypt, so we can create this error.And I'm gonna do bcrypt.CompareHashAndPassword.So here we're gonna (p.hash), okay, to again,the byte representation of plaintextPassword like so.Oops, if err != nil.There're actually a few errors that could happen,one is that CompareHashAndPassword does throw an error if they mismatch, okay?So in this case we're gonna add a switchstatement and here case errors.Is okay?So if the error from calling bcrypt matches the error from bcrypt and its Err, where is it,MismatchedHashAndPassword, okay?So if that's the case, we're gonna return false and nil.Meaning false that the passwords do not match, but there's no true error, okay?Bcrypt just throws an error if it doesn't matches, okay?Otherwise, we're gonna have our default case.So if error does not equal to nil and is the error MismatchedHashAndPassword err,what we're gonna do is default, return false and err, okay?So this is something like an internal server error, right?Internal server error, like something's going on.Otherwise, if anything is great, we can return true and nill.Now, if we go back to our user_handler and we are underneath this part with how do we deal with their passwords,we can now make use of those password functions we just created.So here we can do err, we can put user.PasswordHash.Set, okay?We can put in (req.Password), like so.Next, let's check the error.So if error != nil, what we can do is h.logger and we can just do Printf not fatal, we can do ("ERROR").>> Melkey: You can say hashing password, again, this is going to be for us.So %V, err, whereas we'll respond to our client.We can use utils.WriteJSON(w,) we can do http.StatusInternalServerError, okay?And this part gets kinda dicey, because, like I showed you earlier,well, if we're setting this not a problem.But for when we do matches, you don't wanna tell a potential bad actor,like a fraud actually try to hack an account,that combination of username exists and the password's wrong, right?Then they know, okay, so there's actually a user with that username or email in your database, I just have to crack the password.So again, my expertise is definitely not security or how to handle that.I'll refer to some experts to give the best suggestions.But when you do respond to your client,you don't explicitly say, hey, password is not correct.You just kinda give a broad statement, say,we can't match the two combinations of using our password, for example, right?But again, I'll refer to experts in the field on what they suggest for handling that.But in this case, because we know we are just setting the password,we know that we can do error, "internal server error", and we can just return.>> Melkey: All right, now, with all of that being done,we can finally call the function that creates the user, so here we can do err.We can call h.userStore.CreateUser,and we can pass in that user like so.If err != nil go ahead and just copy the logger and the Write.JSON with the return.So instead of hashing password,we can make registering user, just notice the typo up here.>> Melkey: And you can keep it like that.And while you copy that down, we're gonna do that.If there is no error, we're able to successfully create the user.We can do w, http.StatusOK, and we can also send back utils.Envelope,we can say "user", and bring that user like so.And actually, it's not StatusOK,StatusCreated is the more appropriate status response here.We did the database layer, we did the API layer.We just have to do one last layer, which is the easiest, and that's routing it across our application, which we know how to do.We first should start in the app.go like so.And now, since we've introduced a new store,we can go all the way up here, okay?Let's first create the new UserHandler *api.UserHandler, like so.And then right here, we can do userStore :=store.NewPostgressUserStore, pass (pgDB).And in here, userHandler := api.NewUserHandler.We'll pass in the userStore and the logger, like so, andthen underneath UserHandler, we'll pass in the userHandler.Last thing we got to do is, go into our routes.And let's do r.Post, this is gonna be "/users", andhere app.UserHandle.HandleRegisterUser, all right?So now we have fully connected everything.Again, we do this one much faster.We've connected our user database to our user API,across our app, through our routes.Only thing left is to test it.So we have this HandledRegisterUser, go to your running go server,you can nuke that, run go run main.go, see if you have any obvious errors.I do not, that's good.Make sure you Docker is still running, okay?>> Melkey: Check, select all.>> Melkey: Okay, if you've got that issue, I'm just double checking that just toconfirm I don't have any users in my database, select all from users,psql shows me it is empty.And if I just go back to the post_notes.txt.If I go down to section 3.1 right here,I've provided an example payload request for you to copy andpaste into your terminal or into your URL application, or app API application.So paste this, you can see here it's curl -X POST, which is the method.Localhost:8080/users, the application type, and then the payload,which includes a username, email, password and bio.So click enter, you can now see we've gotten a response, "user", "id": 1,"username", "email", "bio", "created_at" and "updated_at".And now if I go to psql and run the exact same command to check if we have a user.You now should see we do, in fact, have our username, John Doe,with all of their credentials.And you can notice the password is, in fact, hashed.
8.6 Token Authentication & OAuth 2.0
06:21:58 - 06:29:04
>> Melkey: Yeah, okay, moving on, so this gives us the ability to create users,now, let's talk about authentication.Okay, I'm gonna switch over to here.So I'm gonna briefly talk about this,there's different types auth methods, right?I'm sure most of us, if you've used auth before,you know that typically you have used one of these three.And the three that I could think of, and I'm sure they're probably more,but the main three that I'm aware of is stateful token authentication,stateless token authentication and an OAuth 2.0, all right?I'm going to briefly give you an overview of all three, andI'm going to tell you which one we're going to use.OAuth 2.0 I'm sure we're very familiar with this, it's whenever you use an application, and it gives you the prompt to sign in with Google,sign in with GitHub, sign with X, Y, Z, you can sign in with this.TLDR is using a third party provider like Google,GitHub, to basically store and validate who you are.If you have a Google account and they know that you're legit,if GitHub knows you're legit, we can use that logic,that kind of ramp to also validate if you're legit for our application, right?If you're good enough for Google and GitHub, maybe a good enough for us,that's kind of how I like to view it.There is a lot of really good pros to this, essentially Google and GitHub,they store everything rather in your system.You have to store their password, you have to store all these other information.You may store things related to their user profile on your site, but in terms of like things that could go pretty nasty, like passwords, gonna leave that to them.There is this possibility that you may be storing a token, right?So typically when you get a redirect from Google or Github or whatever third-party identity provider, it's like, hey, here is this token, it is a temporary token.It has a short lifespan, which you then can basically handshake to get a longer term token with the identity provider.And then how you handle the token tool up to you can store in your database,you can store in a client that's how you authenticate a user with OAuth 2.0.Super fast implement lots of libraries that does it, lots of Pros,some cons is like you obviously don't have access to their data,and you don't really have the full scope of the user.And also, you're dependent on a third party.If Google goes down and your only way of authenticating is through OAuth 2.0 point using Google, you're kind of out of luck, right?So pros and cons, so stateless token auth is something we are all familiar with,this is JSON web token or a JWT pronounced.And here, this is where everything is essentially encoded into a token,that is basically encrypted into three parts.A JWT has the hashing algorithm that's used to create the JWT,it has the signing signature of who created and issued that JWT, and then it has information that you choose to encode into the JWT itself.This is typically stored on client side,like in memory so on, like a cookie or local storage.You'd get a JWT, store it there and you use it to authenticate, and this is great, right?It's typically done in memory.All the information is kind of contained within the token itself.And a really good pro is that you don't need to perform an additional databaselookup to really authenticate who that user is,because that will be typically stored on the token itself.Now there are some cons to this, such as,once you issue the JWT, you can't revoke it.You have to change the signing method of what you use to sign that JWT, right?JWT, JWTs typically have like, expiry of 24 hours, but let's say you issue it and then you get a call that says, hey, my account was hacked, it logged in.What do you do now?You have to change the signing method,of your system because you can't retract that JWT at all.Once it's out in the system, all you can do is when you when it comes back asa request, say that that signature is no longer valid,because we've revoked that or we changed the signature, okay?That's gonna affect all the JWT on your system in case you do it in a pretty creative and intense way.Another thing, common with JWTs is if you store the wrong info on them,they could be pretty easily hacked.Anything on the client side like cookies, local storage, it's fairly safe but nowadays, like a lot of things are getting hacked,a lot of people are getting really smart.Again, I hate to use the example of LLMs, but they're tools to be used to do this kind of stuff, right?So you typically want to encode the JWT with like superficial information,never store the password or anything important in a JWT, right?And then the last one is stateful token auth, okay?And this one is the hash,the token is actually stored server side in a database with a user ID and expiry field, these tokens, think of it as just a different table in our database.It's gonna have a token table, that's gonna have who it belongs to the scope ofit, when it expires and how can we use it, right?The real good pro about this is our back end maintains control over the token throughout the entirety of the token.So we issued that token, the users can use it, but if we detect they're a bad user,we can easily just nuke that thing, from one call in our database,that thing's gone.We don't change any signing methods, we don't do anything like that,just that thing's gone, that's it, we clean our hand out of it, right?Because we have control of it in terms of our database.The con to that is, that requires an additional database call.You have to check the integrity of that token through this new tokens table,which hence token handler which double hence token data store.And I wrote this little snippet I don't know why I probably feel a littlezesty, I guess.But even with a JWT, you probably would be doing additional database calls to pull additional info even with a JWT, so I mean, is it truly a con?We can debate that, it does take a bit more time to set up,so you can just use the library like JSON or whatever and use it.You actually have to do a little bit of setup, so we're gonna be using this one.We're gonna be using stateful token auth,it's rolling your own auth, some would say.I think that really blew up in 2023,if you have a strong opinion on it, obviously, I understand it and acknowledge it, I do think that was really blown out of proportion.If you're not creating the own hashing algorithm, I think you should be okay ifyou use a shot 256, that's already made by computer science theorists,I think you are okay to handle token authentication yourself.So with that, that's what we're going to be exploring.
8.7 Creating a Tokens Table
06:29:05 - 06:33:31
>> Melkey: Let's go into the migrations here.Oops, that's neither of them.And here we're gonna create our new table.So we're gonna do 1234, 4, I'm just gonna call it tokens.sql, like so, okay?Just to make it faster, go ahead andjust copy any of the other existing SQLs as a starting point for us.And so we're gonna create table if not exist instead of users, andyou can call it tokens.We don't need any of these fields at all, so just delete those like that.The first field is gonna be a hash, like this.It's gonna be byte a format, so this is native to Postgres.Okay, this is gonna be acting as our primary key.>> Melkey: Okay, next, we're gonna have the user_id.The big int is going to be NOT NULL,and it's going to be REFERENCES,users on the users(id), field and ON DELETE CASCADE.so if we delete a user,we're going to delete all the tokens associated with that user.>> Melkey: Every token has an expiry that we can control.>> Melkey: So we can put that as a default timestamp, like so.And then with time zone not null.And then we have scope.And this is gonna be text.And this can also not be null.So, not null.Make sure you modify the drop table.So it's no longer just users, but it's tokens.With that, we can actually use goose migration.All right, so we have this new table, but if we go to our psql/4/dt, it's not there.So how can we get it up, right?I don't want to delete the database.Is there any way to just insert it?Yes, we can use goose.So at the root of your project, you can go ahead and run Goose, andput the command here.So this is gonna be the command.Now, it looks pretty nasty.But what's actually happening is you're commanding Goose,where the directory is that has a SQL file, andhas all the versions of Goose up so we've run before, and that's in migrations.We're telling it what is the database, so we're using Postgres,and then that is simply the connection string, okay?So it's Postgres, we're using Postgres, it's gonna be the user Postgres,where the local host is, what the database name is, and what the port is.So very similarly, when we were in database.go,and even our test db, we have the connection string,this is just a different way to represent that connection string.Instead of having it nicely separated,we have concatenated into one core connection string for our database.And again, watch the 5432, that's my port.If it's not your port, change that accordingly.And also make sure your database is, in fact, running.So you do still have docker compose up.>> Melkey: So if you click enter, hopefully you should see an OK with this,okay, it notifies that the fourth SQL file in the migrations folder.And it said, successfully migrate database to version 4.>> Speaker 2: We have the same, ZSH command not found.Take an export again.>> Melkey: For goose?>> Speaker 2: [CROSSTALK] >> Melkey: Yeah, okay so what this is likea temporary solution export path you can actuallyjust persist that into your .zshrc, >> Speaker 3: Yeah, soif you really just type that into your- >> Melkey: Instead of .zshrc, right?>> Speaker 3: Yeah. >> Melkey: Yeah, or .bashrc,whatever you're using, cuz I think this just keeps it alive forthe state of the terminal, for the session state.And then when you go open up a new terminal or fail to reload it andresource it, I think it just goes away.Wait, now, if it's in the zsh, it's always gonna be referred to it.And this is also helpful, yeah, I do actually recommend putting it in your .zshpermanently, because this is just a Go bin, right?So everything you install with Go will be in this directory, so then anyGo in talk moving forward will be always referred to through .zsh to this path.Nice, that worked.Yep, okay.
8.8 Generating JSON Web Tokens
06:33:32 - 06:49:19
>> Melkey: So we just created our new token SQL table, andwe run the migration to get that working.Next, let's go ahead andwrite a package that will allow us to generate these tokens.So in internal, go ahead and make a new one called tokens, a new folder calledtokens, and then within tokens, make a new file called tokens.go.It's not gonna be in store is going to be in internal.So within internal, make a new folder called tokens, andit was in that make a new file called tokens.go.Because I want it to be its own separate package and not part of the store package.So here we can do package tokens, as opposed to package store.Either would be fine.The structure I'm choosing is gonna be packaged tokens,even though we're going to be going back into the tokens.go file in store..>> Melkey: Okay, cool.So again, this is gonna require a struct, so we can do type Token struct,and it's gonna have the field that we just basically saw in our SQL table.So first, we're gonna have a plain text which is going to be a string.We gonna have a json representation of that, and just say token.>> Melkey: Okay, I'm gonna have the hash, which is gonna be a slice of bytes.Excuse me.Json, we wanna not pass this around to our client, so let's omit that.Or specifically, just dash it out so it does not get sent out.We have our UserID, there's gonna be an int.We also do not want to reveal who is calling this or what users calling this.They should know if they are the ones truly calling it.We do not need to pass any ID or any PII text.Next we'll have an expiry, we'll make this time.Duration, okay?Or sorry, time.Time.>> Melkey: We'll use a duration function after, okay?Here we'll pass in expiry.>> Melkey: And then scope which is going to be a string.And again, the caller does not need to know the scope of this at all.>> Melkey: [COUGH] So we have our token struck, andinstead of making like a constructor,we're just gonna have one function that just generates the token, okay?So, it's gonna be pretty straightforward function.All it's going to do is from nothing, we're gonna create this token, andthen that token will be inserted into the database.So here we'll do, yeah?>> Speaker 2: You got a missing.>> Melkey: Right here?Hell yeah, thank you.Okay, so here we'll do func GenerateToken.Okay, and it's not a method receive, run token.You may think that, but if you think about it,we need to first create a token to have methods on the token, right?And because this function will be responsible creating the token,it needs to come first, chicken versus the egg.So here, we'll have user ID, it's gonna be an int.It's gonna have also a time to live, which will be time.duration.And to have a scope, which is gonna be a string, andthis is going to return a pointer to our token and an error, all right?So let's go ahead and assemble our token here.So let's make the address of token like so, UserID.We'll just pass in userID directly.Expiry is gonna be time.Now.>> Melkey: .Now, okay?And we'll do add the TTL, the time to live.So whatever time is .now, if you want your token slip for 24, hours, 10 hours,one hour, one minute, we're basically saying whatever the time is now,add that TTL to it, okay?So we know what timestamp this will expire at.>> Melkey: And also the time package can go is very nice.>> Melkey: And then the scope will be the scope, okay?Here we're gonna make an empty bytes of 32 characters.So here, we'll use the make function like so, we'll have our slice of bytes,okay, and then we'll put 02 bytes like, so >> Melkey: Next,we're actually going to use the rand package.So random, this is built into go.We'll do rand.read, I'm gonna pass in those empty bytes.>> Melkey: Just gonna basically fill in the slice of bytes,which is the random assortment of random characters.>> Melkey: If the error does not equal to nil, this is gonna be an internalserver error, meaning the random library or our system something's going on.So we can just do return nil and error like so, okay?And then for token, plain text, what we're gonna use is base 32.>> Melkey: Standard encoding, okay?This is gonna be us actually encoding the plain text password into our token.>> Melkey: Gonna say with padding.>> Melkey: Base 32, no padding.And then we're gonna do encode to string,we're gonna pass in the empty bytes like this, okay?And just to kind of explain what this is, so with padding creates a new encoding,identical with this, except with a specific padding character orno pattern to disable padding.So padding is typically seen as like for UTF-8.Sometimes I believe it's the extra equal sign at the end if there's an emptycharacter, empty slot.So that's what the width padding does.It just pads up if you send a value that doesn't fully meet the length of what youset your encoder to be, it just pads it with, typically the equal sign at the end.>> Melkey: Okay, so now we have the token, plain text.What we're going to do is create our hash,which means sha256 should bring it into crypto/sha256.>> Melkey: Then we're gonna use the sum 256.Functions returns a shot 256 check some of the data.All of this, I'm just being honest, is us not creating our own hashing algorithm.This is built in to go the shot 256 library, the crypto library,and the random library.It's just us essentially, we're rolling our own auth using algorithm hashingtools created by much smarter people than me, and in use by a lot of people.So again, I think rolling your own auth, some people think this is the part whereyou're actually making your own algorithm, like doing all this stuff.That's not really what it is.We're leveraging tools, sometimes external tools,but because of, I guess, the richness of the ghost standard library,we can use these tools that are available to us.>> Melkey: Okay, so here we can just pass in a slice of bytes, andthen what we're gonna pass in is token.Plaintext, all right?And then here all gonna say is token.Hash like sois going to be hash, bring in that entire slice,and here we're gonna return token and nil.And so one thing I realized that I may have forgot to mention is the scope.Tokens, the way we are using them,could have many different scopes.We can have authentication scope, but you can also have authorization scope.You could have mod scope, admin scope, grandfathered in scope, right?And these are just basically levels of privilege that we can assign to a usercommunicated through tokens that can be used across our application, okay?So here in our instance, because we're using authentication,we can create a const, all right?And this const could be called ScopeAuth forright now we can just make this equal the string authentication like, so.Cool, so now we have a method of creating tokens.So generate token, and we have the token struct,we can then go back to our store here.And within store, we can finally create tokens.go.And the reason why I didn't create the other file in the store is because thatother file, as we just saw, has nothing to do with the database.And so for me, I like that separation here this file in particular,let me just quickly spin it up package store.This is gonna be our tokens.go talking directly to our database.So we'll be inserting those values.So I thought it makes more sense to separate them.But if I'm being honest, you can't keep them in one file.I'll leave it up to you if you want to change it up andwhatever makes more sense to you, okay?So in this case, we don't actually need to create a struct,because we already have it from our tokens package.But we can do is not a func, butwe can create a type to handle our Postgres token store, right?So we can do PostgresTokenStore.This is gonna be a struct, and it's gonna have a field db.It's gonna be of type sql.DB which you've seen plenty of times.With this, we can create our new constructor.So func new Postgres token store, okay?It's gonna take a db like so,it's going to return a pointer to Postgres token store like so,and we can return the postgres token store db, all right?This should be pretty familiar to us already, and with a store,we can also do something called type token store as an interface.>> Melkey: Now, the chances of changing the underlying structure of a token storeis still fairly high because all really doing is changing that constructor,that new Postgres token struct, so it's as equal across the board, right?So that's why you would it's not necessarily saying you're changingfrom a sha256, algorithm token, or even stateful versus stateless.All this is saying is you no longer use Postgres to store your token.So that's why it's still applicable to have a interface on it as well.The methods on this interface are gonna be token,which is going to be of type token,which can do token.to bring it in.>> Melkey: I think my editor is gonna do it for me.So here, let's just move all this github.com/melkey.Let me remind myself of what it is.FemProject, cool, and that's a little helpful thing if you forget like me.>> Melkey: Okay, and then it's just slash- >> Speaker 2: Is it tokens?>> Melkey: It's token, cool.Yeah, so don't forget the internal and don't forget the the plural of tokens.Okay, cool, so then over here, it's not token, it's tokens.And then we can put token like that.>> Melkey: Okay, so insert this is gonna be what's actually gonna be communicatingwith the database.We're gonna be taking that generate token andactually inserting it into the database.All we really need this is to have an error, andthen two more methods will be createNewToken, all right?And this gonna include information like the userID,which we know is gonna be an int, ttl, which is time.Duration.It's also gonna have a scope which is a string, andthis is going to return a pointer to tokens.token and an error, okay?And then one more method we can have is deleteAllTokensForUser, right?And let's say someone gets hacked.Let's say someone wants to just delete all their tokens they haven't been on fora long time.They got banned, whatever it is,you can just easily make a function which takes user ID int and scope string.You can do error like so.>> Melkey: So we have our three methods we know exactly what we need to implement.Let's go ahead and do that.So Postgres token store, let's do CreateNewToken.We'll start with this and like, the signature already tells us,we just have to user ID.It's gonna be int.>> Melkey: Ttl is time.Duration scope is string..This is gonna return a tokens.Token and an error.>> Melkey: Okay?>> Melkey: So here we can do token error is gonna be tokens.GenerateToken.I'm gonna pass in the user ID, the ttl and the scope.>> Melkey: I'm gonna check the errors, we're gonna return nil and error,if there is one.Otherwise we're gonna do error is going to be t.Insert,even though it doesn't exist just yet.But since we know the token signature, insert is going to take our tokens,we're gonna drop it in here, and we can say, return token error.>> Melkey: Next method, let's do Postgres token store.Let's go ahead and just create the insert one since we've already referenced it.All right, so token is going to take token tokens.Token, like so.And it's going to return the error or a error, okay?And here we're gonna create ourquery insert into tokens, okay?And here we're gonna be inserting hash_id,expiry, and scope >> Melkey: Values are gonna be 1,2, 3, and 4, like that, okay?And very easy, we can just do error is gonna be t.db.Exec.Pass in the query and the four values we need, token andthe orderly appear If you're in, so token.Hash,token.UserID, token.Expiry, and token.Scope.>> Speaker 2: For the t.insert?>> Melkey: Yeah.>> Speaker 2: Was that insert, it's a Postgres token store,which doesn't have the insert on it.>> Melkey: That's what we're building right now.>> Speaker 2: Okay, so it's just not there yet.>> Melkey: But yeah, the,the function building now is the insert on the t.Postgres token store.>> Speaker 2: Gotcha. >> Melkey: Yeah.>> Melkey: Yeah, so now if we do return error and you save,your error should go away on the t.insert.Because now the Postgres token store struct does have a method on it calledInsert.Rewriting this last function, so we do t we have PostgresTokenStore, andthe last function you wanna create is going to be DeleteAllTokensForUser.This is gonna take a userID of type int and the scope, which going to be a string.It's going to turn an error for us.And quickly create a query like so.It's gonna be DELETE FROM tokens.Oops, where scope equals the first value passed in.>> Melkey: And user_id = the second value.>> Melkey: Then we can just execute this with t.db.Exec,pass in the query, pass in the scope first, and then the userID.And then we can go ahead and return error like so.
8.9 Token API Handlers
06:49:20 - 07:00:13
https://frontendmasters.com/courses/complete-go/token-api-handlers/
>> Melkey: So we went SQL layer, database layer,we know where we're going API layer.Let's go into the API, we're gonna make a new file calledtoken_handler.go, package API like so.Quickly create our handlers and these shrugs,we can do type TokenHandler struct.This one can be a little different, cuz not only we're gonna havethe tokenStore of store.TokenStore, we're also gonna have a userStore.UserStore, that's also gonna have our logger,which *logger., oops, not that.Like that, okay?Func NewTokenHandler, let's go ahead andcreate this, can take a tokenStore type store.TokenStore,userStore type store.UserStore, logger like so.This is going to return a pointer to TokenHandler.Go ahead and return TokenHandler and fill out those fields to tokenStore,tokenStore, userStore, userStore, and then logger is logger.Oops.>> Melkey: Cool.>> Melkey: Okay, we'll basically create one function here,which going to be creating a token for authentication.>> Melkey: But since this is gonna be create method, and we've now handled,I think, two different create methods, one for user,one for workouts and even updating.We have to always remember that we have the ability to dumpthe data from our client into a placeholder structure.And that should be ringing the bells of a struck, we can use another struck, right?So we can do type, we can call this createTokenRequest, this gonnabe a struct that we're gonna decode the information we get from our client, okay?So here we can put Username is gonna be a string,>> Melkey: Like this, andthen the password is gonna be a string 'json:"password"', like that, right?Now that we have that, let's go ahead and create our method on the TokenHandler,which is gonna be HandleCreateToken, like so.It's gonna be http.ResponseWriter, andour pointer to http.Request, let's get ourselves more room here.So first, let's go ahead and parse the request.So we're gonna declare this variable request,which can be of type createTokenRequest, the struct we just created above.Let's go ahead and decode everything in there, so josn.NewDecoder(r.Body),I'm gonna decode this into the address of request like so.If error does not equal to nil, let's check thoseerrors with h.logger.Printf, I can just say ERROR.Okay, and we can say,createTokenRequest, right,module o v, let's put err.Then we can use our utils.WriteJSON package (w, http.StatusBadRequest,utils.envelope), let's put "error" in here.And over here, we can say invalid request payload,okay, and then let's make sure we return out of it.>> Melkey: So this is pretty standard stuff we've done a bunch of times already.So first we're gonna retrieve if the user exists by username.Then they usually we know exist.If they do, we're gonna check invalidate the passwords,if they match we will then issue a token, okay?So first, let's get the user, we can do this cuz we've already at the user store.We can already do this since we've created the function to do that,which was get user by username.So we can do user, err, is gonna be h.userStore,that's our TokenHandler has the userstore within it.We can do GetUserByUsername(re.Username), okay?If err != nil || user is nil,okay, h.ogger.Printf,we can say ("ERROR: GetuserByUsername:"%v") utils.writeJSON(w,http, and we can say StatusInternalServerError).>> Melkey: Okay, let's go ahead and return.>> Melkey: So at this point on that line, we should have two pieces of information.We have the request information from our decoding, andthen we also have a user struck from getuser by username.Next thing we wanna do is validate those passwords so we can do passwordsDoMatch,or something like that, and that's obvious, error is going to be,>> Melkey: User.PasswordHush, all right,.matches, so this is the second function we created a little bit ago,and we can do (req.Password), okay?If err != nil, we definitely wanna handle this,we can h.logger.Printf("ERROR: PasswordMatch,you can just do PasswordHush_Mathes.>> Melkey: Nope, utils.WriteJSON, okay,so w, http StatusInternalError,>> Melkey: InternalServerError,utils.Envelope("error":).And then we can just put "internal server error" like so,let's make sure we return.>> Melkey: Okay, and then here, if the passwords don't match,if the passwords do not match, right,we can use the exclamation point operator to evaluate boolean expression.So this would be, if it's not true, or if it's false,we can do utils.WriteJSON(w), we can do http.It's not gonna be internal server errors, can be StatusUnauthorized,we can do utils.Envelope("error":) and then the error message this time,we could just say, "invalid credentials".>> Melkey: Keep it broad, can make sure we add the return statement there.And now at this point,we can say that we've validated a user with the right username that they exist.Now we've matched the password we sent with the password that we've hashed usingbcrypt.Okay, so let's actually go ahead and issue this token file,let's do token, err is going to be h.tokenStore.Let's create this new token, I'm gonna pass in user.ID.We're gonna give it a 24 hour lifespan, so 24*time.Hour, okay?And for the scope, we'll do tokens.scopeAuth like so,I'm gonna go ahead and handle, so here, if err != nil,>> Melkey: Supposed to be error,I said password matches, we can just say couldn't create a token.So Creating Token.So this is still gonna be an internal server error,we can keep it like so, we can return out and in here.We can do utils.WriteJSON(w, ) we can dohttp.StatusCreated, okay, utils.Envelope.We can say something like, you see something like "auth_token", andthen the associate token like this.Whatever you wanna call it, token, auth_token,secret_token, whatever, it's all up to you.But just to be mindful that your client will have to decode that JSON asauth_token.Hopefully this is making sense.Hopefully, at this point the pattern is very obvious, like handler,database, SQL, app, route.go, it's very defined.And I think it scales really nicely, right, it's very containerized.TokenHandler, you know exactly what's gonna happen here, andthen you can match it with tokenStore and be like, okay, I see what's going on here.And then if tokenHandler has a userStore, you know exactly where that is, see,look, okay, I can see what's happening here.But with that being said, let's go back to our app.go,since we do need to hook up the tokenhandler here.So, TokenHandler and api.TokenHandler, like so.And actually this is a TokenStore,we'll just do store.NewPostgresTokenStore,this is gonna take our DB, so pgDB.Can get mad at us, and here we do TokenHandler,it's gonna be api.NewTokenHandler, like so.It's gonna take the TokenStore, the userStore and logger.And then put TokenHandler as TokenHandler in the actual return application struct.All right, let's head on over to the last place we can modify,which is this location here, the routes location.So here, this is for users when they want to authenticate.So you can use them like ("/token/authentication"),like that, and we can do app.TokenHandler.HandleCreateToken,again remember, we're passing it as first class citizens.

8.10 Testing the Authentication Routes
07:00:14 - 07:02:48
https://frontendmasters.com/courses/complete-go/testing-the-authentication-routes/
>> Melkey: Time for us to check if this works.Let's go back to our running Go server.Run it down and go run main.go.Is there any obvious errors?No? That's good.You can see it's updated to the current version of four, which is great.Okay, if we look at p s q l, select we'll do a /dt.We now see we have our tokens table right here.If we do select all from tokens, we have nothing there.If I quickly double check select all from users,you can see we have one user, John Doe.I'm actually going to create a new user called Jack_,not to be confused with John_Doe, but just to demonstrate that,you just can't create an account and then we can use that account to authenticate.So you go back into the post_notes.txt, you should see under section 3.2,we actually have two sets of code requests.So here we can take this one, which would be the usual, which creates A new user,right?So I'm gonna go ahead and copy this.I'm gonna paste it right here into my terminal.So now I have this new user, id 2.Username, jack_doe, jack.doe@example.com, we can check again, select all from users.There they are, john doe and jack doe, very nice.And if you go back into the POST notes and take the second curl request,which is going to be to /token/authentication.So if you go ahead and grab this and you paste it here,make sure that the username is, in fact, jack_doe.If you don't wanna use that, just make sure matches the username of the useryou've created or the other user you have in your database.Make sure the passwords match as well.And if this works, you should see now we are able to generatean authentication token for our user Jack Doe.And if you want, we can be a little bit more let's try,let's see what if this is 124 right?Invalid credentials.So there's ways that we can validate that this does in fact work, butnow we can guarantee that our username Jack Doe has a token.And if we double check in PSQL, if we do select all from tokens,you can now see Jackdaw has a hash token Token.His user ID is 2.We don't really know who that is.The expiry is 24 hours from now, and the scope is authentication.

9.0 Middleware
58m 44s
9.1 Getting User Tokens
07:02:49 - 07:10:57

>> Melkey: So we just finished confirming that we now are able to create tokens forour users, we've seen these token we can use them.And now let's take it one step further into routing this with Middleware andactually having proper authentication.Cuz right now, we just get the token, but it's really not doing much for us, right?There's a lot of different ways that we can use authentication tokens,like making sure that the workout belongs to the correct user.And we're gonna explore this in the next couple of submodules.So, let's actually start this off in our user_store.go file.Cuz what we're going to be doing here is we're gonna be adding a few things.We're gonna be setting ourselves up for our Middleware, okay?So you can see we have our User struct here, and this is great.What I'm going to add is var AnonymousUser.And this is going to be simply an empty user struck, okay?Now, why would we need something like this?Well, if we think about it, users who join our app, our web app,whatever it is, they don't have to be logged in the first time to use it, right?When you before even register for account,you are technically considered an anonymous user.So we are going to be leveraging this ability of creating this variable,which was going to be used as validation in our Middleware to determine ifa user is a, anonymous, not logged in, or if they are in fact logged in andthey are a full user with the struct fills, okay?So this is gonna set ourselves up.I'm gonna add a new method here, so func u, it's gonna be a method on user.Okay, I'm gonna say IsAnonymous, all right?It's gonna return a boolean.And all it's going to do is return u, so compare it to an AnonymousUser.So if the user is an empty user struck, we know they are anonymous.Else they are logged in.We are anonymous.And the next function we wanna build here is wewant to also retrieve who a token belongs to.Cuz right now, if two of Jack Doe and John Doe both create their tokens andthey submit a request with that token, we need to identify who does thattoken belong to and what privileges does that token have.And can they do things to certain workout apps that, for example, if I createa workout and I'm John Doe, I don't want Jack Doe deleting it or doing stuff to it.So I want to make sure that my authorizationtoken is correctly adhered to, and to do that,we start by creating a new function called GetUserToken, all right?So take a scope, a tokenPlainText, both of which are gonna be of type string.And it's simply going to return a User and an error.So we get user token.Did we implement it?No, we did not.Okay, let's go func.So we're gonna implement the GetUserFunction here,we used s, so we can do (s *PostgresTokenStore) like so,okay, and then we do GetUserToken.Okay, GetUserToken has to adhere to scope, which would be a string,and then plainTextPassword, also a string.And then here it's gonna return a pointer to User as well as an error.Let's give ourselves more room.Okay, and then here, what we're going to do is retrieve the hash of the token.I'm gonna try to compare it to the color of this function.So first, we'll do tokenHash is going to be sha256, we'll bring it for you.I'm gonna do sum256, and it will be a slice of bytes like so.Now put in the token, the plaintextPassword like so.>> Melkey: Oops.>> Melkey: Then we can go ahead and create our query.Okay, so this query is gonna be the, I would say, most advanced query we'll do.I think it might be the last query we'll do.But this is going to be actually an inner join.So we're gonna be selecting the values from our user table andmatching them with the values from our token table, okay?So we do an INNER JOIN based on the ID of the token, sothe token user ID field as well as the user id field.Okay, so it's gonna be a little more complicated than the ones we've seenbefore, but it's not gonna be too atrocious.So here we can do SELECT.We'll do u.id, and u is gonna be representing of the user's table,u.username, u.email, u.password_hash.And these are values from our user table, sou.bio u.created_at, u.updated_at, like, so.FROM users u, so we're saying that the users table, instead of writing user.id,user.bio, we can just use the shorthand notation of u.And we can do INNER JOINtokens t ON t.user_id = u.id.Okay, and we can say WHERE t.hash = the first value passed in ANDt.scope = the second value we passed in.And we have to check the expire, and t.expiry > than the third value.>> Melkey: And that third value is gonna be time.now.So I'm gonna compare it to the current time.I wanna execute this to the expiry of something that's in our tokens table.So here we can declare our new user.So let's say User like so.>> Melkey: We can do PasswordHash.It's gonna be a password struck.>> Melkey: Oops.>> Melkey: Okay, and then we can declare our error.I'm gonna call this, so s.db.QueryRow,I'm gonna pass in that query, and then the three values we wanna pass in.So first would be, let's copy the sliceof tokenHash like so, then the scope.All right, and then the last one will be time.Now.And here, we'll do Scan.I'm gonna scan the values, all right?So the values that we're gonnascan into are gonna be user.ID,user.Username, user.Email,user.PasswordHash.hash, user.Bio,user.CreatedAt, and user.UpdatedAt.Make sure add the comma.If err is sql.ErrNoRows.Okay, so if there just doesn't happen to be any of the values andreturn just the empty set, we can just return nil and nil.>> Melkey: Make sure this is a pointer.>> Melkey: Okay, if error does not equal to nil,we can just return nil and the error itself.And then lastly, can return user and nil.

9.2 Modifying Request Context
07:10:58 - 07:18:27


>> Melkey: So with that done, we're actually gonna introduce another packageinto our application, and this is gonna be the middleware package.So if we go into internal, go ahead and just close these down.Go ahead and add another folder called middleware, andthen we'll do Middleware.Go.It will be its own standalone package.Go ahead and call this package Middleware, okay?This is gonna have a type user Middleware.It's gonna be a struck, okay?This struct is gonna have a user store field,which gonna be a type store user, store like that, okay?And then here, we need to create two new functions.And these functions are going to be basically injecting andextracting values from the request.body pointer?So HTTP request, it's a pointer.Typically, we've seen it and we've seen that.We've been able to use the R.body object from it.This time, we're gonna be able to basically interject incomingrequests through that pointer, using our middleware, andtell it is the person calling this an anonymous user or a user who's logged in?So to do that, we're gonna create two new functions.The first one is going to be set user, okay?These are not gonna be methods on the user middleware.These can just be standalone functions that exist in the middleware package.It's gonna take an HTTP request, right?So that pointer, cuz we're gonna be modifying it.And it's also going to take a user, which is type PointerStore.User, like so.>> Melkey: And it's gonna respond with HTTP request, okay?Because we're modifying it, andwe're going to respond with that modified HTTP request pointer, okay?So here we'll have the context, because what we're going to do is goingto be inserting our user into the context property of request,not the body, but context, right?So every request that comes through the point of HTTP requesthas this property of context.So here we have context.I'm gonna create this using the standard context library from Go.So we need context with value.You should see got brought in context package.And here we're gonna take the context that gets brought from request.So, r.context like so.And here we're gonna put, not like that.But here we're gonna add a new value to the r.context.I'm gonna first add a user key.So first, you may think the first thing you wanna dois add like a user key like so and then user.And this is gonna be completely fine andwe can return r.withcontext and pass in context, okay?So this is fine, but what will end up happening with that user key, you're gonnapotentially have collisions of different users with the request param, okay?So what you can typically do is you can have a separate type that youdefine as a context key, which will be a type string, andyou can set your user context key as a value user using that key.So here I'll make a new type called context key, which will be string.Okay, but it's its own individual type here andI can do something like const user context key.It is going to be context key, and then we can put in something like user.>> Speaker 2: Do you  on the collisions a bit more?I'm not fully understanding.>> Melkey: So if we have just the string like this, user key.With the way the context package works,you'll end up getting collisions on just the string type.So you have to make like your own custom type, which is still a string,and then you can embed it using something like user or user key.And then instead of putting the user key here,you can just put a user contacts key like so.I didn't mean to do that.>> Speaker 3: You could have multiple keys that are of type string that are the samestring value, and by creating a new type, then when it indexes that key orwhatever in context because it's a different type.>> Melkey: Yeah.>> Speaker 3: That's what differentiates it.>> Melkey: Yeah, yeah, cuz the different native type behind it.Okay, so we have this set user store again.So this set user function, it's not used right now, butwe're gonna create a function off our middleware.And that function is going to be using the set user.And then we don't really need to have this function right now, but what we can do isdo func getUser, and it's gonna be kind of the opposite of setUsers.It's gonna retrieve the value here.So this is still gonna take an r, which can be a pointer to HTTP request, okay?And it's gonna return a store.user for us.And what we're gonna do here is user, okay, and here we'll do r.context, okay?We'll get the value associated with context, and here is,we'll put in the user context key to retrieve that value, andwe'll see it makes sure that this asserts if the type is in fact Store.User.So this notation of the dot and comparing the types,these assures us that the type that we're retrieving fromthe context is value is going to be of type, store.user.A pointer to store.user, okay?And so if this is not okay, this is similar to like mapping,like if map exists or not, we can use this okay notation as well.So if it's not okay, so if it's not the same type, we can handle this error.We can bubble it up typically, though we could also,in fact, panic on this as well, right?You can do panic, let's say missing user in request.Because at this point, once we hook this up, we expect every request that'sgoing to be calling getUser is going to have a pointer to store.user.Whether that's anonymous user or whether that's a logged in user.So if something is not there, we could panic.The reason behind the panic is like this: could it be a bad actor call, right?Like a hacker, or something.So we could pack on this.That is a bit of an intense handling of it that basically crashes into our app.So I'll leave it up to you.I will typically use something like panic, honestly.And if anything's going to try to be interjected,like a bad call, or insert something through my application,I'll panic it, or I'll kind of close the HTTP layer.Okay, so now that we have the user,we can just return user like that.

9.3 Authentication Middleware
07:18:28 - 07:25:24


>> Melkey: So now we have these two helper functions to modify,to inject the context and also to retrieve the value from the context.Let's go ahead and create a function so it's gonna be on user middleware,and this function is gonna be called authenticate, okay?And all this is gonna do this authenticate function is gonna be a wrapper on ourexisting http handler function.So all those functions that we've declared in our routes.go.handle, getUserID,handleCreateWorkout, etc., etc., this is gonna wrap them, right?And the way this can work is when authenticate gets wrapped by a function,we want the next handler function to work right away.We want authenticate to do its thing, andthen we want the next chain of http methods to be called right after that.And so we can do this by writing next the call, http,what it's gonna accept is going to be HandlerFunc, okay, andit's going to respond with an http.Handler like so.And then here we can, right away,just return http.HandlerFunc, like this.It's gonna be anonymous function func,which is going to take w, http.ResponseWriter, which again,this is a signature of all those handler functions, http.Request like so.And so now within here, within this anonymous function,we can interject any incoming requests to our server, right?Any incoming request that we wrap authenticate around, to be specific.So if you wrap them around all of them, we will have thisinterjecting every single call that we get, okay?So with that, we can first start by adding a w.Header.I'm gonna add a vary and an authorization tag,so authorization like so.Here we can do authHeader, okay, andwe can do r.Header.Get so it's gonna request orget all of the headers associated with authorization.>> Melkey: Give ourselves some more room, okay?And then we can check if it exists or not.So here, if authHeader isan empty string, right?So that means this request, there is no authorization attempt.We can do r, is gonna be SetUser, so we're gonna passan r since it's the first argument that user expects.And then we can do store.AnonymousUser like this.So now, because the caller here did not supply us with an authorization header,we know, or at least we can assume this is an anonymous, not logged in user.And so with that, we can just simply do next.ServeHTTP(w,r), so then it's going to go into the next function in the chain,and then we can return like so.Otherwise we can start checking header parts is going to be strings.Split,okay, we're gonna pass in the authHeader.At this point, we assume that the authHeader is not an empty string, andit does, in fact, exist.I'm gonna split it on spacing here because, remember,it's going to be something like Bearer <TOKEN> or authorization TOKEN, right?So this is gonna be the space between the string is what we're going to be after,what we're gonna be validating here.So here we split header parts into two equivalent pieces.So here we can do if len(headerParts) is not equal to 2,or headerParts at the 0th Index, okay,does not equal to something like Bearer.>> Melkey: Okay, can do utils.WriteJSON, w,we can do http.StatusUnauthorized,utils.Envelope, we can say error.>> Melkey: The invalid authorization header,like so and then we can return.>> Melkey: And so with that, we know that the header part at the one, sothe second part at the first index is actually the token.So token would be headerParts,1 like so, then user err.Now we can use that token to retrieve any sort of user.So we can use userMiddleware, UserStore,we can use that new function GetUserToken like so,we can put in the token itself.Let me just remind myself, yeah.So this first argument is scope here, sowe can do tokens.Scopeauth and then the token underneath, okay?We can check that err.So if err does not equal to nil.Here we can do utils.writeJSON w,http.StatusUnauthorized like so, utils.envelope.We can say error, all right, andwe can say just invalid token.>> Melkey: Okay, if user is nil, all right, we can do the same thing.So let's just go ahead and also add the return.>> Melkey: We can say, if the user is no, can do StatusUnauthorized, andwe can do error.Instead of invalid token, we can just say something like token expired or invalid.>> Melkey: At the end, we can do r = SetUser r,and put in that user, you can donext.serveHTTP, (w, r) return.

9.4 Protecting Routes with Middleware
07:25:25 - 07:36:31


>> Melkey: So with a new middleware handler, let's go back to our app.go andadd this new middleware handler.So in application we have our token handler.Let's add middleware, like so, okay?And this is gonna come from the middleware.User middleware package.Okay, it gets auto imported.>> Melkey: So we have an error.So, GetUserToken, let's see what's going on.So PostgresTokenStore, this sort of,okay, PostgresUserStore, there you go.Now it's happy.I put the wrong PostgresTokenStore on the method receiver there.Make sure it's PostgresUserStore,or else you get errors that the interface you're using isn't satisfied there.We'll do the middleware, I guess we can call it handler, okay?And here we can just say, middleware.UserMiddleware, like so.And then here, because we're going to be instantiating a struct,we don't really necessarily need a constructor every single time,we can instantiate it in place like this.So we can do middleware.UserMiddleware.And then user store will be that UserStore variable.And down here we can do middleware, is middleware handler, like so.All right, we have one more spot to modify, which would be in routes.go.And this is gonna be a pretty interesting one.So here you can see that we have all of these methods declared.We have a get methods, post, put, delete, etc, etc.So CH actually offers us this really cool way of groupinga bunch of these functions together.And then we can basically facilitate if any of themare going to require a middleware or not.So it gives us more control and granularity over kinda, this access layerto what a logged in user, not logged in user, and admin user can hit andaccess through our different methods here, our different routes.So, we can do this by, right underneath the chi.NewRouter, you can do r.Group.You can see here,group creates a new inline mux with a copy of the middleware stack.It's a useful group of handlers along the same routing path that use an additionalset of middlewares, okay?So again, you can also group them by /V1.You can have your V1 routes here.You can also group by V2 and have your new modified routes there.But an aspect that I like about this is it allows us to add a middleware intothis group and have the functions within the group kind of adhere to them, okay?So here we can do an anonymous func.So func, r will be a chi.Router, like so.Open the function body up.First argument will be r.Use.Or not argument, but the first thing we'll write is Is r.Use.And then we put app.MiddlewareAuthenticate as a first class citizen.And we can actually just see our .use,use appends more middlewares onto the router stack.So exactly what we just built as our middleware,we can now append it to the existing Chi muck stack.So can do r.Use and app.MiddlewareAuthenticate.So I had to repeat myself, I just want to make sure that was clear, okay?And then we can go ahead and take the workouts/{id} GET method,and all these methods here.Okay, so the handle GetWorkoutByID, CreateWorkout, UpdateWorkout,DeleteWorkout.Actually, we don't even need to bring in the CreateWorkout, we can leave that out.Actually, let's bring these ones, yeah.So the GetWorkout, CreateWorkout, UpdateWorkout, and DeleteWorkout,we can take these and drop them within the group that we just defined.And then you should have three methods outside of that grouping,which is HealthCheck, HandleRegisterUser, and HandleCreateToken, okay?So now if we save and we restart our server.>> Melkey: Okay, no obvious scary errors.You can go here into one of our other terminals.Clear., we can do the health check.So curl localhost:8080/health, everything should be working accordingly.But you may be thinking,why do we just spend all this time to do something that has really no benefit?Cuz if you notice, if you go back to our middleware here in the method,regardless of the case for a person without any auth headers orall of this logic, the end is still the same.We're still just going to set the user and then serve the HTTP,the next function that's in the chain HTTP method, right?But really, we haven't done anything.Okay, so if we go back to our routes here for a second, here,it's grouped with this authenticate method.Okay, cool, so all requests are gonna be injecting with anonymous user ora logged in user.But as far as the scope of these functions, they actually don't care.They're gonna act the same way.There's no logic telling them to behave differentlydepending on what that value is within the context.So in the next bit, we're actually going to introduce a new functionthat's actually going to wrap each individual protected route, and it checksif the user in the request context is an anonymous user and logged in user.And then what to do.Do we want to give them access to the rest of the route, or do you want to just sayblock them and say, hey, you cannot access these routes at all?So if we go back into our middleware right here,we can go all the way to the bottom and can give ourselves some more room.So, I just want to very much emphasize the point of what happened, right?We just blanketed a bunch of routes with this middleware.And all this authenticate method does is insert user that's anonymous orinsert user that's not anonymous.That's it.And so, this following function is going to be able to receive that context,call the getUser function and from the getUser function, depend ordecide what to do, pass or no pass.So, how does that look?We can do func, is gonna be a user middleware, andhere we can call this function requireUser.>> Melkey: Okay, a requireUser, it's also going to have that same ability topass on to the next HTTP function right away.It's gonna be http.HandlerFunc, like so, andto respond with an http.handlerFunc, all right?And right away we can return http.HandlerFunc.We're gonna call it an anonymous function.So, Func w HTTP ResponseWriter,pointer to HTTP request.I'm gonna open this up, and here we're gonna do,user is going to be getUser, pass in r.And here we're gonna evaluate.If user.is anonymous, I'm gonna do utils.writeJSON.I'm going to respond with w.And here I'm gonna do HTTP status unauthorized.>> Melkey: Oops.>> Melkey: Okay, utils.envelope, and here we can just say error.And say, you must be logged in to access this route.Okay, and then we can return.>> Melkey: Next we can just do next.serverHTTP(w, r).And that's all those functions going to do,cuz the heavy lifting was already done by the authenticate middleware that'sinjecting what that anonymous user or user struck is.And getUser is gonna be a very simple function that justextracts the value from that.>> Melkey: So now, if we go back to routes, these functions here,we can actually do something pretty cool.We can do app.Middleware, and we can do RequireUser,and we can wrap these functions around it, like so.>> Melkey: Okay, so you can see we had this app.WorkoutHandler handlegetWorkuoutID.And now we're passing it andwrapping around this app.Middleware.RequireUser function.>> Melkey: Okay, so then we can do app.Middleware RequireUser.>> Melkey: Can do it to all of them.Or if you want, you can even add it to a upper header of the use function.Having it fully authenticate via this required user.I'm being a little bit more specific and individually wrapping each andevery single HTTP function I want a user to be present for.There's many different ways you can handle it.You can have your authenticate, you can even have another function here, so r.Use,and you can have another one that checks all the required users, if you want.And that can be part of the grouping.Or we can just handle them individually like this.>> Melkey: And now, if we go back to our Go, let's bring down the server.Go run main.go like so.Okay, that all works.If we go back to the exact same terminal, if we run the exact same curl,this should work, because status is unavailable, right?But if you do some like curl localhost:8080/workout/2,you can see you must be logged in to access this route.Because I just called it as some random nobody, right?Some anonymous user.Again, the specific person would probably ask,why are we blocking access to getting workouts?This is just an example.This is a very just core example.Probably you want to have the ability for anonymous users to look at workouts andperuse and check out your app to an extent.And maybe you do these kind of blogs on creating a workout, updating a workout,dealing a workout.But the the core here is that we're demonstrating that you canfully block access to routes that you control and that you choose.

9.5 Adding User ID Migration
07:36:32 - 07:42:19


>> Melkey: We're close to wrapping up, but there is one very,very obvious issue in this entire app, not middleware at all, and it's the factthat people can still create workouts and delete them however they want.There is no core safety between someone deletingall of my workouts that even if they don't belong to them.And if you remember at the very, very beginning in migrations,in workouts, we have this commented out, this user ID.Well, we have come to the time where we're gonna basically startgiving every workout an associated user ID.So user IDs are gonna be responsible of creating a workout,no more will people be quote, unquote, anonymous to create workouts,and this will allow us to validate if the person submittingthe request is in fact the owner of that workout, okay?And so how do we do this?Well, if we go back, we're not gonna uncommon this,we're gonna leave this we won't touch this file anymore, but under migrations,we're gonna create a fifth file, okay?We're gonna create 00005.This file, we can call it user_id_alter.sql.>> Melkey: All right, so it should look like just an empty file, but go ahead andjust copy an existing SQL file cuz it would save us some time.So paste it, let's go ahead and save.Okay, so we're not gonna be creating a new table, butwhat we're going to be doing is alter table.The table name is gonna be workouts.All right, and this is truly a good use of of migrations.We're modifying the schema of this table, okay?And here we're gonna do add column, okay?User_id, I'm gonna describe what this user_id is,it's gonna be a BIGINT NOT NULL REFERENCESusers(id) ON DELETE CASCADE.And then DROP TABLE, we're not gonna be doing any drop tables.So on the goose down ALTER TABLEworkouts DROP COLUMN user_id.And with that if we go back up, here we can rerun our same Goose command,so you might have it saved, so I recommend just using this up.So goose -dir migrations postgres, and it's just the up command at the very end.And if you run this, you should see this error, this is intentional.I wanted to showcase this because what I wanted to do is highlight the importanceof really understanding your data before you go too deep in programming.The reason why we can't use this is cuz we have already.If you go into PSQL and we select all from workouts,we have a workout here already.And if we were to introduce this new column,this user_id that makes a relation to our users table,how do we find who remade this entry, right?Do we call everyone, all of our users?No, so the unfortunate side of this is this migration,although convenient to execute via Goose,it still presents a giant flaw in the architecture engineering, right?So especially dealing with user databases with relational database to user fields oreven other fields, make sure that when you are adding a field that ifit is a field that references another table, you make a backup orsome way to identify how to make that successful relationship.Because the answer here is, there is no good answer.We actually have to delete and wipe the data here.So NPSQL right here, what I'm gonna do is write DELETE FROM workouts like so.And if I run this, it should say I've deleted one workout.So here, DELETE 1.We can validate that that no longer exists.We also validate from workout_entries that they are in fact empty.So ON DELETE CASCADE does work indeed.So with that, we can now rerun our Goose command, andhere we are on successfully migrate database to version five.So yeah, just kind of sound like a broken record all because we have the abilityto make migrations doesn't excuse any kind of laziness on the engineer side, right?So again, just beware of the feature you are going to addthe level of your application, right?If your app is already having the content of thousand of users,there's certain features that gonna be very complicated to add if they do requireadding a new relationship, right?That has to be some creative fields, creative ways to do that.Some of this does actually involve making a back of the DB in a scriptto put that data into the modified database.So I just wanna kind of give a heads up on how to handle something like this.Cool, so now, if we go to psql and we do select all from workouts,we can see we now have our new user_id field and that is working pretty well.

9.6 Validating User Workout Ownership
07:42:20 - 07:53:16


>> Melkey: Okay, sowith all of that, we do have to make some modifications on our existing code.Specifically, if we go back into our workout_store here,we now know that our workout right here has a new field so we can do User ID.This can be an int json:user_ id andwhat I want to do is add another function here similar tothe get token user function we saw in our token handler.I wanna create a function called GetWorkoutOwner, sowe can do GetWorkoutOwner inside of our workout store interface.ID is gonna be an int 64 and what this is gonna respond with is an int andan error because it's going to respond,you can make this respond with the full user, if you want.I'm just gonna make it pretty easy to respond with the ID of the user who ownsthat workout, okay?Cuz these are primary keys, so they're unique by nature.And so we know that in our case, our primary key is just 1, 2, 3, 4,not the best, but you can do UUIDs and have the same effect here, okay?So if we go into create workout,we do have one thing we definitely need to address, and that is,every time we create a workout, we need to insert that user ID now, okay?So here, let's put the first argument as user_id,that's gonna be in front of title.So you should have user_id, title, description,duration_minutes and calories_burned.Let's make sure we add a fifth value here, okay?And then a few lines below we have the the QueryRow,excuse me, right after the query,we can add workout.UserID, okay?And this is gonna guarantee that we have the ability now when we insert our workoutthat's associated with the user ID.And we don't have to worry about the one to many relationship forthe workout entries, since that could be related back to the workout, andthat will have the associated owner or user ID with it.So if we scroll all the way down, we're gonna start implementingthat new function method we have, so we can do func pg.You can see PostgresWorkoutStore, okay?GetWorkoutOwner, excuse me.It's gonna take the workoutID, which is of type int64.All right, it's gonna return an int, error like so.And here we can do var userID is gonna be an int.We're gonna go ahead and create our new query like so.I'm gonna do SELECT user_idfrom workouts, WHERE id = 1.Okay, you want an only value we will pass, andhere we can do pg.db.QueryRow, pass in that query here,and then we're gonna pass in the workoutID like, so.>> Melkey: Okay, here we can call our Scan method,we're gonna Scan the result into that user ID.If the error does not = nil, what we're going to do?Is just return 0 and specifically the error,otherwise, let's go ahead and return that userID and nil.All right, sonow we just have to make some last finishing touches into the actual handler.So now if we go to workout_handler over here.We don't really care what the handle get worked by ID let anyone read any workout.I think where we start to care is,handling if we want to update a workout and especially creating a workoutbecause like you saw in the data store, we've now inserting a user ID.So we need to make sure we get that user ID field inour handle create workout, okay?So, where we can do this, is let's say right here,we're gonna extract the value of the current user.So we can do currentUser like so, we can just put middleware.GetUser like this.We can pass an r, okay?And here we can say just extra validity check,we don't really need to do this, but here if currentUser == nil,or current user == store.AnonymousUser.We can just simply write this out.>> Melkey: Error, we can just say you must be logged in, okay?So now that we have this current user and we know that they are not anonymous andthey do have this current user.id field,what we can do is workout.userID equals currentUser.ID like that.All right, so now we know in the workout struck,we'll have the user ID associated to it.So when every new user gets created or every new worker gets created,they'll have a user ID associated with it.All right, now there's a few functions typically or just namely update anddelete that we need to just finalize here, okay?So again, the core issue that we're solving is the fact that someone cancreate a workout and someone else can delete it, or someone else can update it,which we don't wanna do.We want owners to delete and update their existing,workouts, okay?So we can do this very easily, so here, right after the,let's see where can we put this and decode it.I guess we can even put it all the way down here, sounderneath the check, so we're in the update workout function.And then right underneath all those up the request,we can do the same thing of getting the currentUser.So we can do middleware.GetUser (r), all right,we can do the same check if currentUser == nil orcurrentUser == store.AnonymousUser.We can simply just send them that they are unauthorized andwe can return out of this.>> Melkey: Okay, error must be logged in to see this.>> Melkey: Okay, next we can actually get if we know the current user,we still need to identify who the owner of the workout is.So what we can do is workoutOwner err, okay?We can use wh.workoutStore and GetworkoutOwner,this function here, you can pass in that (workout ID).>> Melkey: Okay, and here we can do some pretty cool checks here,so if our err does not = nil, we can do a few things.So here, we can do if errors, we can do.Is, sowe've seen this before when we did our testing forour database error, can do sql.ErrNoRows, okay?Here we can write quickly, copy andpaste this down here, >> Melkey: Okay, soit's not that it's a bad request, buthere it's going to be a StatusNotFound, okay?And in here we'll say error:workout does not exist, okay?Or some sort of error order doesn't exist, okay?Otherwise, outside of the scope of the if errors is error no rows, what wecan write is internal server error, so something seriously messed up happens.So StatusInternalServerError, you can do error andjust type internal server error like so,it makes a return from both cases here.All right, so now we know the current user, we have the workout owner as well.What we can do is, if a workoutOwner does not = currentUser.ID.We can basically know that this is an incorrectattempt at modifying someone else's workout, okay?So here we can just grab this.>> Melkey: So you chose JSON, not status, internal server error,but we can do StatusForbidden.All right, you can do error: you are not authorized to update this workout like so.Right at that finish line,the only thing we have to do is now modify the delete workout, okay?So this should handle updating the workout, here we're goingto also modify our handle, delete workup ID with the exact same way.And a lot of this could be abstracted into its own separate function, especiallythe retrieving the current user, a lot of that is pretty rinse and repeat.We can actually just go ahead and just copy the current user andeven the workout owner bit all the way up here, right?So current user, all the way down to our last error check of get workout owner.And if you go back into the handle, delete, workout,right above the delete workout function call on workout store,you can just go ahead and paste this.All right, so I'll go a little slow,but we have the currentUser from our middleware.We have the workout owner that we have as well and then we just simply needto make that last check, so if workoutOwner does not = currentUser.ID.We can then bring back that StatusForbidden,return that we saw right over here, or nope.Where is it? Right over here, return, andjust paste it over here.

9.7 Testing API Endpoints
07:53:17 - 08:01:39


>> Melkey: So we just finished kind of doing some finishing touches on ourworkout store.And so in the following part of the course, the kind of final parts,we're gonna go through all of the different scenarios of curling,all of the endpoints that we have.So if you see, in the post notes dot txt underneath section 3.5we have a ton of different curls that we're gonna be exploring here, okay?So if you want to follow along, this is what we're going to be doing, andI'm gonna be on annotating everything that I do.So first, let's go ahead and quickly just tear down and tear up the go server.So go run main dot go.Any obvious issues, no, it's still on version five, which is great.The next part, we still have Docker compose running.So our DB is running and we still have psql, okay?So again, we can check select all from workouts, everything's fairly empty.Select all from users.We have two users, John and Jack, which we will not be caring about, okay?We're gonna be making some brand new users.We can still use them if you want, but I'm gonna prefer to justcreate new ones just to check if everything works as it should.I'm gonna make this new terminal, I'm gonna clear my terminal.And then the first request I'm gonna be making is creating a new user.So if we go back into the section 3.5,there's this curl request here to create a new user.This one has this John Doe, I'm gonna just change this.Let's change this to Melkey.All right, and let's change this to melky@example.com,let's go ahead and grab this.Go back here, if we paste it, we now have our melkey user, okay?This is good, we know we at least haven't regressed, right?There's nothing that mess this up for us.>> Melkey: Next thing is now we know the username, melkey.I'm gonna go back to the post here, andthe second curl request we have is to authenticate.I'm going to go ahead and grab this, I'm gonna go over here, I'm gonna paste it.I'm gonna make some changes, soit's no longer username john doe, it's gonna be username Melkey.All right, press enter, we have our auth token.Now what I'm gonna do, is I'm just gonna quickly, just copy this auth token andgo back here.I'm gonna make another separate note that just says, text or tokens dot text.You don't need to necessarily do this, butto demonstrate and have user Melkey and token here.Okay, so this is a token associated with Melkey, it's a lot for 24 hours,it's something that we can control.We can, again, double check, select all from tokens, there you go.User ID three, that's Melkey, expires this time.The scope is authentication and it's hashed.Cool, we've also already seen this,it's nothing really new to us, okay?Now if I go back to post nose,you should see that we have this other request to create a workout, okay?So I'm gonna go ahead and just copy this, I'm gonna go over here,I'm gonna paste this.Now, if I run it with this bearer, this is a completely different token.This token is not the one I just copied over here.They're very different, right?This one begins RV-7, and this is one that I stored from many moons ago.So if I run this, token expired or invalid.Good, okay, so we have some letter protection for people trying to createworkouts that they can't, their token expired or the permissions changed.So I rerun that exact same command.But this time I changed the bearer from that old random onethat's in the postnotes dot txt file.And just bear with me as I go ahead and delete this.Okay, if I go back here, I'm gonna go grab the one thatstarts with RV-7, the one we just saw me create.If I send this now, we have this new workout, okay?So workout ID 3, user ID 3, jogging, I'm not a big fan of jogging.Select all from workouts, you can see here now my morning cardio, it belongs to me.Select all from work out underscore, entries.>> Melkey: You can see that we have jogging.Okay, cool, so that's pretty nice, that's pretty cool.We have a way to allow people who are logged in correctly to make modifications.All right, that's pretty awesome.Now that we know this workout belongs to me,I'm going to do is I'm gonna make a new user.Let's go all the way back to our post underscore notes and let's go here.This is a request to create a user, right?So I've already created a username, Melkey.If I paste this, let's go ahead and make a new username.We're gonna call this one dustin, all right?>> Melkey: It should be dustin@example.com, okay?If I click enter again, we know this works.We have our new user, dustin cool, and let's give dustin a token.So, let's authenticate, let's grab this.If you go over here, username, let's just put dustin here.>> Melkey: Cool, we have the new auth token that belongs to Dustin.So now let's grab this.Let's go back here into the tokens dot txt node to remove this annoying line.So now user, this one belongs to a Dustin, andtheir token is like that, okay?So two very different tokens, one is RV-7, the other one's SYL.So the thing I want to validate is, can Dustin update my workout,or can Dustin delete my workout, right?Everything we just did, we have to kind of go back and fix it, it's gonna suck.However, if you can't,then we know that we have everything working accordingly, right?We've already validated that anonymous users can't do things that they're notallowed to do.We've already validated the validity of tokens.Now we need to make sure that we check that ownerstruly can update an owner's workout.So here and quickly clear this just so we have more room.Go back to post notes, and in here, we should have this pull request right here.So the last coral request in that file, I'm gonna go ahead and copy this,I'm gonna paste it.Few things we need to change.So here, instead of workout 6, I believe if we go here,it is what select all from workouts, it is workout 3, okay?So the ID of that workout is three, and quickly replace this.[COUGH] you can see the content of the body is updated cardio.So instead of jogging, I realized I was actually walking.And over here, I'm gonna bring back Dustin's token credentials.And we know Dustin did not create this workout the initial work,I did not create workout three.So if I paste this and I run this,you're not authorized to update this workout right?Which is expected, because now we actually have the logic that extracts the token.We know who the user belongs to.And if we kind of go back and remove Dustin's SYLtoken, >> Melkey: And we go over here andgrab Melkey's token that is definitely not expired.Go here and paste it, and if you run this, we now updated the cardio,and we can validate this from select all from workouts.And now it says updated cardio, a relaxed 45 minute walk after dinner.

9.8 Wrapping Up
1m 54s

9.9 Wrapping Up
08:01:40 - 08:03:34

>> Melkey: That's the entirety of the course as it stands.And I think we've done quite a bit.The first kind of section of the course, we really looked into preliminary go,introduced syntax to go for some people who maybe never written go before.And then we actually just from scratch, created this entire projectwith an API layer and app layer, a middleware, entire routes,a way to roll your own auth and handle the tokens with migrations,composing it with tests, and there's quite a bit more.But with all that, it was awesome having to do this course.


==================================
YOUR GOAL NOW AS THE PROFESSOR AGENT TRAINNER:

could you read, analyze, follow these steps and create action plans, work flows, flow charts of fucntions, relations, modules, files etc >>> so that a new 
student / human can walk through step by step
then teach human how to do so step by step

Put in the file Project_Builder_ModelA with descriptions, instructions and especially action plans or work flows or flow charts of fucntions,or relations,or modules,or files
===============================================================

awesomr thansk you professor Model Builder

so now you know the course, you also know my current project, know my project details, know where my project status is at from the project functions, files, folder and even the Scan_project

Please help with final assesment process so .... 
Option "99: Evaluating the current status of the project !" 
so everytime I run this program, the Scan function would carefully go to details and check :
- current status whcih step ?
- what is next step
> % finsih Quantity
- mistake, error, 
- structure
- analysis
> % Quality

>>> Advice for next step
>>> Advice for improment

>>> Sub Scores. Final Score. Ratings. 

This is awesome :D thank you professor

============================
that is awesome ... thanks 
but please check your grading system. 
why do I have 0% on sub section and especailly Final Score is 0

I did some have lot of codes and they are building

I also have some sub score 20, 60 somewhere here and there 
